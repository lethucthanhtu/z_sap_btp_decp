{
  "_entries": [
    {
      "name": "three/examples/jsm/controls/OrbitControls",
      "path": "/home/user/projects/z_sap_btp_decp/node_modules/three/examples/jsm/controls/OrbitControls.js",
      "lastModified": 1753858549028,
      "type": "module",
      "originalName": "OrbitControls",
      "code": "sap.ui.define(['exports'], (function (exports) { 'use strict';\n\n\t/**\n\t * @license\n\t * Copyright 2010-2025 Three.js Authors\n\t * SPDX-License-Identifier: MIT\n\t */\n\tconst REVISION = '178';\n\n\t/**\n\t * Represents mouse buttons and interaction types in context of controls.\n\t *\n\t * @type {ConstantsMouse}\n\t * @constant\n\t */\n\tconst MOUSE = { ROTATE: 0, DOLLY: 1, PAN: 2 };\n\n\t/**\n\t * Represents touch interaction types in context of controls.\n\t *\n\t * @type {ConstantsTouch}\n\t * @constant\n\t */\n\tconst TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };\n\n\t/**\n\t * Maps textures using the geometry's UV coordinates.\n\t *\n\t * @type {number}\n\t * @constant\n\t */\n\tconst UVMapping = 300;\n\n\t/**\n\t * The texture will simply repeat to infinity.\n\t *\n\t * @type {number}\n\t * @constant\n\t */\n\tconst RepeatWrapping = 1000;\n\n\t/**\n\t * The last pixel of the texture stretches to the edge of the mesh.\n\t *\n\t * @type {number}\n\t * @constant\n\t */\n\tconst ClampToEdgeWrapping = 1001;\n\n\t/**\n\t * The texture will repeats to infinity, mirroring on each repeat.\n\t *\n\t * @type {number}\n\t * @constant\n\t */\n\tconst MirroredRepeatWrapping = 1002;\n\n\t/**\n\t * Returns the weighted average of the four texture elements that are closest to the specified\n\t * texture coordinates, and can include items wrapped or repeated from other parts of a texture,\n\t * depending on the values of `wrapS` and `wrapT`, and on the exact mapping.\n\t *\n\t * @type {number}\n\t * @constant\n\t */\n\tconst LinearFilter = 1006;\n\n\t/**\n\t * Chooses the two mipmaps that most closely match the size of the pixel being textured and uses\n\t * the `LinearFilter` criterion to produce a texture value from each mipmap. The final texture value\n\t * is a weighted average of those two values.\n\t *\n\t * @type {number}\n\t * @constant\n\t */\n\tconst LinearMipmapLinearFilter = 1008;\n\n\t/**\n\t * An unsigned byte data type for textures.\n\t *\n\t * @type {number}\n\t * @constant\n\t */\n\tconst UnsignedByteType = 1009;\n\n\t/**\n\t * Reads the red, green, blue and alpha components.\n\t *\n\t * @type {number}\n\t * @constant\n\t */\n\tconst RGBAFormat = 1023;\n\n\t// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.\n\n\t/**\n\t * No color space.\n\t *\n\t * @type {string}\n\t * @constant\n\t */\n\tconst NoColorSpace = '';\n\n\t/**\n\t * WebGL coordinate system.\n\t *\n\t * @type {number}\n\t * @constant\n\t */\n\tconst WebGLCoordinateSystem = 2000;\n\n\t/**\n\t * WebGPU coordinate system.\n\t *\n\t * @type {number}\n\t * @constant\n\t */\n\tconst WebGPUCoordinateSystem = 2001;\n\n\t/**\n\t * This type represents mouse buttons and interaction types in context of controls.\n\t *\n\t * @typedef {Object} ConstantsMouse\n\t * @property {number} MIDDLE - The left mouse button.\n\t * @property {number} LEFT - The middle mouse button.\n\t * @property {number} RIGHT - The right mouse button.\n\t * @property {number} ROTATE - A rotate interaction.\n\t * @property {number} DOLLY - A dolly interaction.\n\t * @property {number} PAN - A pan interaction.\n\t **/\n\n\t/**\n\t * This type represents touch interaction types in context of controls.\n\t *\n\t * @typedef {Object} ConstantsTouch\n\t * @property {number} ROTATE - A rotate interaction.\n\t * @property {number} PAN - A pan interaction.\n\t * @property {number} DOLLY_PAN - The dolly-pan interaction.\n\t * @property {number} DOLLY_ROTATE - A dolly-rotate interaction.\n\t **/\n\n\t/**\n\t * This type represents the different timestamp query types.\n\t *\n\t * @typedef {Object} ConstantsTimestampQuery\n\t * @property {string} COMPUTE - A `compute` timestamp query.\n\t * @property {string} RENDER - A `render` timestamp query.\n\t **/\n\n\t/**\n\t * Represents the different interpolation sampling types.\n\t *\n\t * @typedef {Object} ConstantsInterpolationSamplingType\n\t * @property {string} PERSPECTIVE - Perspective-correct interpolation.\n\t * @property {string} LINEAR - Linear interpolation.\n\t * @property {string} FLAT - Flat interpolation.\n\t */\n\n\t/**\n\t * Represents the different interpolation sampling modes.\n\t *\n\t * @typedef {Object} ConstantsInterpolationSamplingMode\n\t * @property {string} NORMAL - Normal sampling mode.\n\t * @property {string} CENTROID - Centroid sampling mode.\n\t * @property {string} SAMPLE - Sample-specific sampling mode.\n\t * @property {string} FLAT_FIRST - Flat interpolation using the first vertex.\n\t * @property {string} FLAT_EITHER - Flat interpolation using either vertex.\n\t */\n\n\t/**\n\t * This modules allows to dispatch event objects on custom JavaScript objects.\n\t *\n\t * Main repository: [eventdispatcher.js]{@link https://github.com/mrdoob/eventdispatcher.js/}\n\t *\n\t * Code Example:\n\t * ```js\n\t * class Car extends EventDispatcher {\n\t * \tstart() {\n\t *\t\tthis.dispatchEvent( { type: 'start', message: 'vroom vroom!' } );\n\t *\t}\n\t *};\n\t *\n\t * // Using events with the custom object\n\t * const car = new Car();\n\t * car.addEventListener( 'start', function ( event ) {\n\t * \talert( event.message );\n\t * } );\n\t *\n\t * car.start();\n\t * ```\n\t */\n\tclass EventDispatcher {\n\n\t\t/**\n\t\t * Adds the given event listener to the given event type.\n\t\t *\n\t\t * @param {string} type - The type of event to listen to.\n\t\t * @param {Function} listener - The function that gets called when the event is fired.\n\t\t */\n\t\taddEventListener( type, listener ) {\n\n\t\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\t\tconst listeners = this._listeners;\n\n\t\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\t\tlisteners[ type ] = [];\n\n\t\t\t}\n\n\t\t\tif ( listeners[ type ].indexOf( listener ) === -1 ) {\n\n\t\t\t\tlisteners[ type ].push( listener );\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * Returns `true` if the given event listener has been added to the given event type.\n\t\t *\n\t\t * @param {string} type - The type of event.\n\t\t * @param {Function} listener - The listener to check.\n\t\t * @return {boolean} Whether the given event listener has been added to the given event type.\n\t\t */\n\t\thasEventListener( type, listener ) {\n\n\t\t\tconst listeners = this._listeners;\n\n\t\t\tif ( listeners === undefined ) return false;\n\n\t\t\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== -1;\n\n\t\t}\n\n\t\t/**\n\t\t * Removes the given event listener from the given event type.\n\t\t *\n\t\t * @param {string} type - The type of event.\n\t\t * @param {Function} listener - The listener to remove.\n\t\t */\n\t\tremoveEventListener( type, listener ) {\n\n\t\t\tconst listeners = this._listeners;\n\n\t\t\tif ( listeners === undefined ) return;\n\n\t\t\tconst listenerArray = listeners[ type ];\n\n\t\t\tif ( listenerArray !== undefined ) {\n\n\t\t\t\tconst index = listenerArray.indexOf( listener );\n\n\t\t\t\tif ( index !== -1 ) {\n\n\t\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * Dispatches an event object.\n\t\t *\n\t\t * @param {Object} event - The event that gets fired.\n\t\t */\n\t\tdispatchEvent( event ) {\n\n\t\t\tconst listeners = this._listeners;\n\n\t\t\tif ( listeners === undefined ) return;\n\n\t\t\tconst listenerArray = listeners[ event.type ];\n\n\t\t\tif ( listenerArray !== undefined ) {\n\n\t\t\t\tevent.target = this;\n\n\t\t\t\t// Make a copy, in case listeners are removed while iterating.\n\t\t\t\tconst array = listenerArray.slice( 0 );\n\n\t\t\t\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t\t}\n\n\t\t\t\tevent.target = null;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];\n\n\n\tconst DEG2RAD = Math.PI / 180;\n\n\t/**\n\t * Generate a [UUID]{@link https://en.wikipedia.org/wiki/Universally_unique_identifier}\n\t * (universally unique identifier).\n\t *\n\t * @return {string} The UUID.\n\t */\n\tfunction generateUUID() {\n\n\t\t// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n\n\t\tconst d0 = Math.random() * 0xffffffff | 0;\n\t\tconst d1 = Math.random() * 0xffffffff | 0;\n\t\tconst d2 = Math.random() * 0xffffffff | 0;\n\t\tconst d3 = Math.random() * 0xffffffff | 0;\n\t\tconst uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +\n\t\t\t\t_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +\n\t\t\t\t_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +\n\t\t\t\t_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];\n\n\t\t// .toLowerCase() here flattens concatenated strings to save heap memory space.\n\t\treturn uuid.toLowerCase();\n\n\t}\n\n\t/**\n\t * Clamps the given value between min and max.\n\t *\n\t * @param {number} value - The value to clamp.\n\t * @param {number} min - The min value.\n\t * @param {number} max - The max value.\n\t * @return {number} The clamped value.\n\t */\n\tfunction clamp( value, min, max ) {\n\n\t\treturn Math.max( min, Math.min( max, value ) );\n\n\t}\n\n\t/**\n\t * @class\n\t * @classdesc A collection of math utility functions.\n\t * @hideconstructor\n\t */\n\tconst MathUtils = {\n\t\tDEG2RAD: DEG2RAD};\n\n\t/**\n\t * Class representing a 2D vector. A 2D vector is an ordered pair of numbers\n\t * (labeled x and y), which can be used to represent a number of things, such as:\n\t *\n\t * - A point in 2D space (i.e. a position on a plane).\n\t * - A direction and length across a plane. In three.js the length will\n\t * always be the Euclidean distance(straight-line distance) from `(0, 0)` to `(x, y)`\n\t * and the direction is also measured from `(0, 0)` towards `(x, y)`.\n\t * - Any arbitrary ordered pair of numbers.\n\t *\n\t * There are other things a 2D vector can be used to represent, such as\n\t * momentum vectors, complex numbers and so on, however these are the most\n\t * common uses in three.js.\n\t *\n\t * Iterating through a vector instance will yield its components `(x, y)` in\n\t * the corresponding order.\n\t * ```js\n\t * const a = new THREE.Vector2( 0, 1 );\n\t *\n\t * //no arguments; will be initialised to (0, 0)\n\t * const b = new THREE.Vector2( );\n\t *\n\t * const d = a.distanceTo( b );\n\t * ```\n\t */\n\tclass Vector2 {\n\n\t\t/**\n\t\t * Constructs a new 2D vector.\n\t\t *\n\t\t * @param {number} [x=0] - The x value of this vector.\n\t\t * @param {number} [y=0] - The y value of this vector.\n\t\t */\n\t\tconstructor( x = 0, y = 0 ) {\n\n\t\t\t/**\n\t\t\t * This flag can be used for type testing.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @readonly\n\t\t\t * @default true\n\t\t\t */\n\t\t\tVector2.prototype.isVector2 = true;\n\n\t\t\t/**\n\t\t\t * The x value of this vector.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\tthis.x = x;\n\n\t\t\t/**\n\t\t\t * The y value of this vector.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\tthis.y = y;\n\n\t\t}\n\n\t\t/**\n\t\t * Alias for {@link Vector2#x}.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tget width() {\n\n\t\t\treturn this.x;\n\n\t\t}\n\n\t\tset width( value ) {\n\n\t\t\tthis.x = value;\n\n\t\t}\n\n\t\t/**\n\t\t * Alias for {@link Vector2#y}.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tget height() {\n\n\t\t\treturn this.y;\n\n\t\t}\n\n\t\tset height( value ) {\n\n\t\t\tthis.y = value;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the vector components.\n\t\t *\n\t\t * @param {number} x - The value of the x component.\n\t\t * @param {number} y - The value of the y component.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tset( x, y ) {\n\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the vector components to the same value.\n\t\t *\n\t\t * @param {number} scalar - The value to set for all vector components.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tsetScalar( scalar ) {\n\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the vector's x component to the given value\n\t\t *\n\t\t * @param {number} x - The value to set.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tsetX( x ) {\n\n\t\t\tthis.x = x;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the vector's y component to the given value\n\t\t *\n\t\t * @param {number} y - The value to set.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tsetY( y ) {\n\n\t\t\tthis.y = y;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Allows to set a vector component with an index.\n\t\t *\n\t\t * @param {number} index - The component index. `0` equals to x, `1` equals to y.\n\t\t * @param {number} value - The value to set.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tsetComponent( index, value ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Returns the value of the vector component which matches the given index.\n\t\t *\n\t\t * @param {number} index - The component index. `0` equals to x, `1` equals to y.\n\t\t * @return {number} A vector component value.\n\t\t */\n\t\tgetComponent( index ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: return this.x;\n\t\t\t\tcase 1: return this.y;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * Returns a new vector with copied values from this instance.\n\t\t *\n\t\t * @return {Vector2} A clone of this instance.\n\t\t */\n\t\tclone() {\n\n\t\t\treturn new this.constructor( this.x, this.y );\n\n\t\t}\n\n\t\t/**\n\t\t * Copies the values of the given vector to this instance.\n\t\t *\n\t\t * @param {Vector2} v - The vector to copy.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tcopy( v ) {\n\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Adds the given vector to this instance.\n\t\t *\n\t\t * @param {Vector2} v - The vector to add.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tadd( v ) {\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Adds the given scalar value to all components of this instance.\n\t\t *\n\t\t * @param {number} s - The scalar to add.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\taddScalar( s ) {\n\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Adds the given vectors and stores the result in this instance.\n\t\t *\n\t\t * @param {Vector2} a - The first vector.\n\t\t * @param {Vector2} b - The second vector.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\taddVectors( a, b ) {\n\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Adds the given vector scaled by the given factor to this instance.\n\t\t *\n\t\t * @param {Vector2} v - The vector.\n\t\t * @param {number} s - The factor that scales `v`.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\taddScaledVector( v, s ) {\n\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Subtracts the given vector from this instance.\n\t\t *\n\t\t * @param {Vector2} v - The vector to subtract.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tsub( v ) {\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Subtracts the given scalar value from all components of this instance.\n\t\t *\n\t\t * @param {number} s - The scalar to subtract.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tsubScalar( s ) {\n\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Subtracts the given vectors and stores the result in this instance.\n\t\t *\n\t\t * @param {Vector2} a - The first vector.\n\t\t * @param {Vector2} b - The second vector.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tsubVectors( a, b ) {\n\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Multiplies the given vector with this instance.\n\t\t *\n\t\t * @param {Vector2} v - The vector to multiply.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tmultiply( v ) {\n\n\t\t\tthis.x *= v.x;\n\t\t\tthis.y *= v.y;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Multiplies the given scalar value with all components of this instance.\n\t\t *\n\t\t * @param {number} scalar - The scalar to multiply.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tmultiplyScalar( scalar ) {\n\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Divides this instance by the given vector.\n\t\t *\n\t\t * @param {Vector2} v - The vector to divide.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tdivide( v ) {\n\n\t\t\tthis.x /= v.x;\n\t\t\tthis.y /= v.y;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Divides this vector by the given scalar.\n\t\t *\n\t\t * @param {number} scalar - The scalar to divide.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tdivideScalar( scalar ) {\n\n\t\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t\t}\n\n\t\t/**\n\t\t * Multiplies this vector (with an implicit 1 as the 3rd component) by\n\t\t * the given 3x3 matrix.\n\t\t *\n\t\t * @param {Matrix3} m - The matrix to apply.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tapplyMatrix3( m ) {\n\n\t\t\tconst x = this.x, y = this.y;\n\t\t\tconst e = m.elements;\n\n\t\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];\n\t\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * If this vector's x or y value is greater than the given vector's x or y\n\t\t * value, replace that value with the corresponding min value.\n\t\t *\n\t\t * @param {Vector2} v - The vector.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tmin( v ) {\n\n\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\tthis.y = Math.min( this.y, v.y );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * If this vector's x or y value is less than the given vector's x or y\n\t\t * value, replace that value with the corresponding max value.\n\t\t *\n\t\t * @param {Vector2} v - The vector.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tmax( v ) {\n\n\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\tthis.y = Math.max( this.y, v.y );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * If this vector's x or y value is greater than the max vector's x or y\n\t\t * value, it is replaced by the corresponding value.\n\t\t * If this vector's x or y value is less than the min vector's x or y value,\n\t\t * it is replaced by the corresponding value.\n\t\t *\n\t\t * @param {Vector2} min - The minimum x and y values.\n\t\t * @param {Vector2} max - The maximum x and y values in the desired range.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tclamp( min, max ) {\n\n\t\t\t// assumes min < max, componentwise\n\n\t\t\tthis.x = clamp( this.x, min.x, max.x );\n\t\t\tthis.y = clamp( this.y, min.y, max.y );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * If this vector's x or y values are greater than the max value, they are\n\t\t * replaced by the max value.\n\t\t * If this vector's x or y values are less than the min value, they are\n\t\t * replaced by the min value.\n\t\t *\n\t\t * @param {number} minVal - The minimum value the components will be clamped to.\n\t\t * @param {number} maxVal - The maximum value the components will be clamped to.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tclampScalar( minVal, maxVal ) {\n\n\t\t\tthis.x = clamp( this.x, minVal, maxVal );\n\t\t\tthis.y = clamp( this.y, minVal, maxVal );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * If this vector's length is greater than the max value, it is replaced by\n\t\t * the max value.\n\t\t * If this vector's length is less than the min value, it is replaced by the\n\t\t * min value.\n\t\t *\n\t\t * @param {number} min - The minimum value the vector length will be clamped to.\n\t\t * @param {number} max - The maximum value the vector length will be clamped to.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tclampLength( min, max ) {\n\n\t\t\tconst length = this.length();\n\n\t\t\treturn this.divideScalar( length || 1 ).multiplyScalar( clamp( length, min, max ) );\n\n\t\t}\n\n\t\t/**\n\t\t * The components of this vector are rounded down to the nearest integer value.\n\t\t *\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tfloor() {\n\n\t\t\tthis.x = Math.floor( this.x );\n\t\t\tthis.y = Math.floor( this.y );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * The components of this vector are rounded up to the nearest integer value.\n\t\t *\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tceil() {\n\n\t\t\tthis.x = Math.ceil( this.x );\n\t\t\tthis.y = Math.ceil( this.y );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * The components of this vector are rounded to the nearest integer value\n\t\t *\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tround() {\n\n\t\t\tthis.x = Math.round( this.x );\n\t\t\tthis.y = Math.round( this.y );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * The components of this vector are rounded towards zero (up if negative,\n\t\t * down if positive) to an integer value.\n\t\t *\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\troundToZero() {\n\n\t\t\tthis.x = Math.trunc( this.x );\n\t\t\tthis.y = Math.trunc( this.y );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Inverts this vector - i.e. sets x = -x and y = -y.\n\t\t *\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tnegate() {\n\n\t\t\tthis.x = - this.x;\n\t\t\tthis.y = - this.y;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Calculates the dot product of the given vector with this instance.\n\t\t *\n\t\t * @param {Vector2} v - The vector to compute the dot product with.\n\t\t * @return {number} The result of the dot product.\n\t\t */\n\t\tdot( v ) {\n\n\t\t\treturn this.x * v.x + this.y * v.y;\n\n\t\t}\n\n\t\t/**\n\t\t * Calculates the cross product of the given vector with this instance.\n\t\t *\n\t\t * @param {Vector2} v - The vector to compute the cross product with.\n\t\t * @return {number} The result of the cross product.\n\t\t */\n\t\tcross( v ) {\n\n\t\t\treturn this.x * v.y - this.y * v.x;\n\n\t\t}\n\n\t\t/**\n\t\t * Computes the square of the Euclidean length (straight-line length) from\n\t\t * (0, 0) to (x, y). If you are comparing the lengths of vectors, you should\n\t\t * compare the length squared instead as it is slightly more efficient to calculate.\n\t\t *\n\t\t * @return {number} The square length of this vector.\n\t\t */\n\t\tlengthSq() {\n\n\t\t\treturn this.x * this.x + this.y * this.y;\n\n\t\t}\n\n\t\t/**\n\t\t * Computes the  Euclidean length (straight-line length) from (0, 0) to (x, y).\n\t\t *\n\t\t * @return {number} The length of this vector.\n\t\t */\n\t\tlength() {\n\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t\t}\n\n\t\t/**\n\t\t * Computes the Manhattan length of this vector.\n\t\t *\n\t\t * @return {number} The length of this vector.\n\t\t */\n\t\tmanhattanLength() {\n\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\n\t\t}\n\n\t\t/**\n\t\t * Converts this vector to a unit vector - that is, sets it equal to a vector\n\t\t * with the same direction as this one, but with a vector length of `1`.\n\t\t *\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tnormalize() {\n\n\t\t\treturn this.divideScalar( this.length() || 1 );\n\n\t\t}\n\n\t\t/**\n\t\t * Computes the angle in radians of this vector with respect to the positive x-axis.\n\t\t *\n\t\t * @return {number} The angle in radians.\n\t\t */\n\t\tangle() {\n\n\t\t\tconst angle = Math.atan2( - this.y, - this.x ) + Math.PI;\n\n\t\t\treturn angle;\n\n\t\t}\n\n\t\t/**\n\t\t * Returns the angle between the given vector and this instance in radians.\n\t\t *\n\t\t * @param {Vector2} v - The vector to compute the angle with.\n\t\t * @return {number} The angle in radians.\n\t\t */\n\t\tangleTo( v ) {\n\n\t\t\tconst denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );\n\n\t\t\tif ( denominator === 0 ) return Math.PI / 2;\n\n\t\t\tconst theta = this.dot( v ) / denominator;\n\n\t\t\t// clamp, to handle numerical problems\n\n\t\t\treturn Math.acos( clamp( theta, -1, 1 ) );\n\n\t\t}\n\n\t\t/**\n\t\t * Computes the distance from the given vector to this instance.\n\t\t *\n\t\t * @param {Vector2} v - The vector to compute the distance to.\n\t\t * @return {number} The distance.\n\t\t */\n\t\tdistanceTo( v ) {\n\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t\t}\n\n\t\t/**\n\t\t * Computes the squared distance from the given vector to this instance.\n\t\t * If you are just comparing the distance with another distance, you should compare\n\t\t * the distance squared instead as it is slightly more efficient to calculate.\n\t\t *\n\t\t * @param {Vector2} v - The vector to compute the squared distance to.\n\t\t * @return {number} The squared distance.\n\t\t */\n\t\tdistanceToSquared( v ) {\n\n\t\t\tconst dx = this.x - v.x, dy = this.y - v.y;\n\t\t\treturn dx * dx + dy * dy;\n\n\t\t}\n\n\t\t/**\n\t\t * Computes the Manhattan distance from the given vector to this instance.\n\t\t *\n\t\t * @param {Vector2} v - The vector to compute the Manhattan distance to.\n\t\t * @return {number} The Manhattan distance.\n\t\t */\n\t\tmanhattanDistanceTo( v ) {\n\n\t\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\n\n\t\t}\n\n\t\t/**\n\t\t * Sets this vector to a vector with the same direction as this one, but\n\t\t * with the specified length.\n\t\t *\n\t\t * @param {number} length - The new length of this vector.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tsetLength( length ) {\n\n\t\t\treturn this.normalize().multiplyScalar( length );\n\n\t\t}\n\n\t\t/**\n\t\t * Linearly interpolates between the given vector and this instance, where\n\t\t * alpha is the percent distance along the line - alpha = 0 will be this\n\t\t * vector, and alpha = 1 will be the given one.\n\t\t *\n\t\t * @param {Vector2} v - The vector to interpolate towards.\n\t\t * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tlerp( v, alpha ) {\n\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Linearly interpolates between the given vectors, where alpha is the percent\n\t\t * distance along the line - alpha = 0 will be first vector, and alpha = 1 will\n\t\t * be the second one. The result is stored in this instance.\n\t\t *\n\t\t * @param {Vector2} v1 - The first vector.\n\t\t * @param {Vector2} v2 - The second vector.\n\t\t * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tlerpVectors( v1, v2, alpha ) {\n\n\t\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Returns `true` if this vector is equal with the given one.\n\t\t *\n\t\t * @param {Vector2} v - The vector to test for equality.\n\t\t * @return {boolean} Whether this vector is equal with the given one.\n\t\t */\n\t\tequals( v ) {\n\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t\t}\n\n\t\t/**\n\t\t * Sets this vector's x value to be `array[ offset ]` and y\n\t\t * value to be `array[ offset + 1 ]`.\n\t\t *\n\t\t * @param {Array<number>} array - An array holding the vector component values.\n\t\t * @param {number} [offset=0] - The offset into the array.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tfromArray( array, offset = 0 ) {\n\n\t\t\tthis.x = array[ offset ];\n\t\t\tthis.y = array[ offset + 1 ];\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Writes the components of this vector to the given array. If no array is provided,\n\t\t * the method returns a new instance.\n\t\t *\n\t\t * @param {Array<number>} [array=[]] - The target array holding the vector components.\n\t\t * @param {number} [offset=0] - Index of the first element in the array.\n\t\t * @return {Array<number>} The vector components.\n\t\t */\n\t\ttoArray( array = [], offset = 0 ) {\n\n\t\t\tarray[ offset ] = this.x;\n\t\t\tarray[ offset + 1 ] = this.y;\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the components of this vector from the given buffer attribute.\n\t\t *\n\t\t * @param {BufferAttribute} attribute - The buffer attribute holding vector data.\n\t\t * @param {number} index - The index into the attribute.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\tfromBufferAttribute( attribute, index ) {\n\n\t\t\tthis.x = attribute.getX( index );\n\t\t\tthis.y = attribute.getY( index );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Rotates this vector around the given center by the given angle.\n\t\t *\n\t\t * @param {Vector2} center - The point around which to rotate.\n\t\t * @param {number} angle - The angle to rotate, in radians.\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\trotateAround( center, angle ) {\n\n\t\t\tconst c = Math.cos( angle ), s = Math.sin( angle );\n\n\t\t\tconst x = this.x - center.x;\n\t\t\tconst y = this.y - center.y;\n\n\t\t\tthis.x = x * c - y * s + center.x;\n\t\t\tthis.y = x * s + y * c + center.y;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets each component of this vector to a pseudo-random value between `0` and\n\t\t * `1`, excluding `1`.\n\t\t *\n\t\t * @return {Vector2} A reference to this vector.\n\t\t */\n\t\trandom() {\n\n\t\t\tthis.x = Math.random();\n\t\t\tthis.y = Math.random();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t*[ Symbol.iterator ]() {\n\n\t\t\tyield this.x;\n\t\t\tyield this.y;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Class for representing a Quaternion. Quaternions are used in three.js to represent rotations.\n\t *\n\t * Iterating through a vector instance will yield its components `(x, y, z, w)` in\n\t * the corresponding order.\n\t *\n\t * Note that three.js expects Quaternions to be normalized.\n\t * ```js\n\t * const quaternion = new THREE.Quaternion();\n\t * quaternion.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), Math.PI / 2 );\n\t *\n\t * const vector = new THREE.Vector3( 1, 0, 0 );\n\t * vector.applyQuaternion( quaternion );\n\t * ```\n\t */\n\tclass Quaternion {\n\n\t\t/**\n\t\t * Constructs a new quaternion.\n\t\t *\n\t\t * @param {number} [x=0] - The x value of this quaternion.\n\t\t * @param {number} [y=0] - The y value of this quaternion.\n\t\t * @param {number} [z=0] - The z value of this quaternion.\n\t\t * @param {number} [w=1] - The w value of this quaternion.\n\t\t */\n\t\tconstructor( x = 0, y = 0, z = 0, w = 1 ) {\n\n\t\t\t/**\n\t\t\t * This flag can be used for type testing.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @readonly\n\t\t\t * @default true\n\t\t\t */\n\t\t\tthis.isQuaternion = true;\n\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._w = w;\n\n\t\t}\n\n\t\t/**\n\t\t * Interpolates between two quaternions via SLERP. This implementation assumes the\n\t\t * quaternion data are managed  in flat arrays.\n\t\t *\n\t\t * @param {Array<number>} dst - The destination array.\n\t\t * @param {number} dstOffset - An offset into the destination array.\n\t\t * @param {Array<number>} src0 - The source array of the first quaternion.\n\t\t * @param {number} srcOffset0 - An offset into the first source array.\n\t\t * @param {Array<number>} src1 -  The source array of the second quaternion.\n\t\t * @param {number} srcOffset1 - An offset into the second source array.\n\t\t * @param {number} t - The interpolation factor in the range `[0,1]`.\n\t\t * @see {@link Quaternion#slerp}\n\t\t */\n\t\tstatic slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\n\t\t\t// fuzz-free, array-based Quaternion SLERP operation\n\n\t\t\tlet x0 = src0[ srcOffset0 + 0 ],\n\t\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\t\tw0 = src0[ srcOffset0 + 3 ];\n\n\t\t\tconst x1 = src1[ srcOffset1 + 0 ],\n\t\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\n\t\t\tif ( t === 0 ) {\n\n\t\t\t\tdst[ dstOffset + 0 ] = x0;\n\t\t\t\tdst[ dstOffset + 1 ] = y0;\n\t\t\t\tdst[ dstOffset + 2 ] = z0;\n\t\t\t\tdst[ dstOffset + 3 ] = w0;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( t === 1 ) {\n\n\t\t\t\tdst[ dstOffset + 0 ] = x1;\n\t\t\t\tdst[ dstOffset + 1 ] = y1;\n\t\t\t\tdst[ dstOffset + 2 ] = z1;\n\t\t\t\tdst[ dstOffset + 3 ] = w1;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\n\t\t\t\tlet s = 1 - t;\n\t\t\t\tconst cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\t\t\t\t\tdir = ( cos >= 0 ? 1 : -1 ),\n\t\t\t\t\tsqrSin = 1 - cos * cos;\n\n\t\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\t\tif ( sqrSin > Number.EPSILON ) {\n\n\t\t\t\t\tconst sin = Math.sqrt( sqrSin ),\n\t\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\n\t\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\t\tt = Math.sin( t * len ) / sin;\n\n\t\t\t\t}\n\n\t\t\t\tconst tDir = t * dir;\n\n\t\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\t\tw0 = w0 * s + w1 * tDir;\n\n\t\t\t\t// Normalize in case we just did a lerp:\n\t\t\t\tif ( s === 1 - t ) {\n\n\t\t\t\t\tconst f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\n\t\t\t\t\tx0 *= f;\n\t\t\t\t\ty0 *= f;\n\t\t\t\t\tz0 *= f;\n\t\t\t\t\tw0 *= f;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdst[ dstOffset ] = x0;\n\t\t\tdst[ dstOffset + 1 ] = y0;\n\t\t\tdst[ dstOffset + 2 ] = z0;\n\t\t\tdst[ dstOffset + 3 ] = w0;\n\n\t\t}\n\n\t\t/**\n\t\t * Multiplies two quaternions. This implementation assumes the quaternion data are managed\n\t\t * in flat arrays.\n\t\t *\n\t\t * @param {Array<number>} dst - The destination array.\n\t\t * @param {number} dstOffset - An offset into the destination array.\n\t\t * @param {Array<number>} src0 - The source array of the first quaternion.\n\t\t * @param {number} srcOffset0 - An offset into the first source array.\n\t\t * @param {Array<number>} src1 -  The source array of the second quaternion.\n\t\t * @param {number} srcOffset1 - An offset into the second source array.\n\t\t * @return {Array<number>} The destination array.\n\t\t * @see {@link Quaternion#multiplyQuaternions}.\n\t\t */\n\t\tstatic multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {\n\n\t\t\tconst x0 = src0[ srcOffset0 ];\n\t\t\tconst y0 = src0[ srcOffset0 + 1 ];\n\t\t\tconst z0 = src0[ srcOffset0 + 2 ];\n\t\t\tconst w0 = src0[ srcOffset0 + 3 ];\n\n\t\t\tconst x1 = src1[ srcOffset1 ];\n\t\t\tconst y1 = src1[ srcOffset1 + 1 ];\n\t\t\tconst z1 = src1[ srcOffset1 + 2 ];\n\t\t\tconst w1 = src1[ srcOffset1 + 3 ];\n\n\t\t\tdst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n\t\t\tdst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n\t\t\tdst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n\t\t\tdst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n\n\t\t\treturn dst;\n\n\t\t}\n\n\t\t/**\n\t\t * The x value of this quaternion.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tget x() {\n\n\t\t\treturn this._x;\n\n\t\t}\n\n\t\tset x( value ) {\n\n\t\t\tthis._x = value;\n\t\t\tthis._onChangeCallback();\n\n\t\t}\n\n\t\t/**\n\t\t * The y value of this quaternion.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tget y() {\n\n\t\t\treturn this._y;\n\n\t\t}\n\n\t\tset y( value ) {\n\n\t\t\tthis._y = value;\n\t\t\tthis._onChangeCallback();\n\n\t\t}\n\n\t\t/**\n\t\t * The z value of this quaternion.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tget z() {\n\n\t\t\treturn this._z;\n\n\t\t}\n\n\t\tset z( value ) {\n\n\t\t\tthis._z = value;\n\t\t\tthis._onChangeCallback();\n\n\t\t}\n\n\t\t/**\n\t\t * The w value of this quaternion.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 1\n\t\t */\n\t\tget w() {\n\n\t\t\treturn this._w;\n\n\t\t}\n\n\t\tset w( value ) {\n\n\t\t\tthis._w = value;\n\t\t\tthis._onChangeCallback();\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the quaternion components.\n\t\t *\n\t\t * @param {number} x - The x value of this quaternion.\n\t\t * @param {number} y - The y value of this quaternion.\n\t\t * @param {number} z - The z value of this quaternion.\n\t\t * @param {number} w - The w value of this quaternion.\n\t\t * @return {Quaternion} A reference to this quaternion.\n\t\t */\n\t\tset( x, y, z, w ) {\n\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._w = w;\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Returns a new quaternion with copied values from this instance.\n\t\t *\n\t\t * @return {Quaternion} A clone of this instance.\n\t\t */\n\t\tclone() {\n\n\t\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\n\t\t}\n\n\t\t/**\n\t\t * Copies the values of the given quaternion to this instance.\n\t\t *\n\t\t * @param {Quaternion} quaternion - The quaternion to copy.\n\t\t * @return {Quaternion} A reference to this quaternion.\n\t\t */\n\t\tcopy( quaternion ) {\n\n\t\t\tthis._x = quaternion.x;\n\t\t\tthis._y = quaternion.y;\n\t\t\tthis._z = quaternion.z;\n\t\t\tthis._w = quaternion.w;\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets this quaternion from the rotation specified by the given\n\t\t * Euler angles.\n\t\t *\n\t\t * @param {Euler} euler - The Euler angles.\n\t\t * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.\n\t\t * @return {Quaternion} A reference to this quaternion.\n\t\t */\n\t\tsetFromEuler( euler, update = true ) {\n\n\t\t\tconst x = euler._x, y = euler._y, z = euler._z, order = euler._order;\n\n\t\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t\t//\tcontent/SpinCalc.m\n\n\t\t\tconst cos = Math.cos;\n\t\t\tconst sin = Math.sin;\n\n\t\t\tconst c1 = cos( x / 2 );\n\t\t\tconst c2 = cos( y / 2 );\n\t\t\tconst c3 = cos( z / 2 );\n\n\t\t\tconst s1 = sin( x / 2 );\n\t\t\tconst s2 = sin( y / 2 );\n\t\t\tconst s3 = sin( z / 2 );\n\n\t\t\tswitch ( order ) {\n\n\t\t\t\tcase 'XYZ':\n\t\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'YXZ':\n\t\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ZXY':\n\t\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ZYX':\n\t\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'YZX':\n\t\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'XZY':\n\t\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );\n\n\t\t\t}\n\n\t\t\tif ( update === true ) this._onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets this quaternion from the given axis and angle.\n\t\t *\n\t\t * @param {Vector3} axis - The normalized axis.\n\t\t * @param {number} angle - The angle in radians.\n\t\t * @return {Quaternion} A reference to this quaternion.\n\t\t */\n\t\tsetFromAxisAngle( axis, angle ) {\n\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n\t\t\tconst halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\t\t\tthis._x = axis.x * s;\n\t\t\tthis._y = axis.y * s;\n\t\t\tthis._z = axis.z * s;\n\t\t\tthis._w = Math.cos( halfAngle );\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets this quaternion from the given rotation matrix.\n\t\t *\n\t\t * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).\n\t\t * @return {Quaternion} A reference to this quaternion.\n\t\t */\n\t\tsetFromRotationMatrix( m ) {\n\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\tconst te = m.elements,\n\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\n\t\t\t\ttrace = m11 + m22 + m33;\n\n\t\t\tif ( trace > 0 ) {\n\n\t\t\t\tconst s = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\t\tthis._w = 0.25 / s;\n\t\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\t\tthis._z = ( m21 - m12 ) * s;\n\n\t\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\t\tthis._x = 0.25 * s;\n\t\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\t\tthis._z = ( m13 + m31 ) / s;\n\n\t\t\t} else if ( m22 > m33 ) {\n\n\t\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\t\tthis._y = 0.25 * s;\n\t\t\t\tthis._z = ( m23 + m32 ) / s;\n\n\t\t\t} else {\n\n\t\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\t\tthis._z = 0.25 * s;\n\n\t\t\t}\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets this quaternion to the rotation required to rotate the direction vector\n\t\t * `vFrom` to the direction vector `vTo`.\n\t\t *\n\t\t * @param {Vector3} vFrom - The first (normalized) direction vector.\n\t\t * @param {Vector3} vTo - The second (normalized) direction vector.\n\t\t * @return {Quaternion} A reference to this quaternion.\n\t\t */\n\t\tsetFromUnitVectors( vFrom, vTo ) {\n\n\t\t\t// assumes direction vectors vFrom and vTo are normalized\n\n\t\t\tlet r = vFrom.dot( vTo ) + 1;\n\n\t\t\tif ( r < 1e-8 ) { // the epsilon value has been discussed in #31286\n\n\t\t\t\t// vFrom and vTo point in opposite directions\n\n\t\t\t\tr = 0;\n\n\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\n\t\t\t\t\tthis._x = - vFrom.y;\n\t\t\t\t\tthis._y = vFrom.x;\n\t\t\t\t\tthis._z = 0;\n\t\t\t\t\tthis._w = r;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._y = - vFrom.z;\n\t\t\t\t\tthis._z = vFrom.y;\n\t\t\t\t\tthis._w = r;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\n\n\t\t\t\tthis._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n\t\t\t\tthis._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n\t\t\t\tthis._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n\t\t\t\tthis._w = r;\n\n\t\t\t}\n\n\t\t\treturn this.normalize();\n\n\t\t}\n\n\t\t/**\n\t\t * Returns the angle between this quaternion and the given one in radians.\n\t\t *\n\t\t * @param {Quaternion} q - The quaternion to compute the angle with.\n\t\t * @return {number} The angle in radians.\n\t\t */\n\t\tangleTo( q ) {\n\n\t\t\treturn 2 * Math.acos( Math.abs( clamp( this.dot( q ), -1, 1 ) ) );\n\n\t\t}\n\n\t\t/**\n\t\t * Rotates this quaternion by a given angular step to the given quaternion.\n\t\t * The method ensures that the final quaternion will not overshoot `q`.\n\t\t *\n\t\t * @param {Quaternion} q - The target quaternion.\n\t\t * @param {number} step - The angular step in radians.\n\t\t * @return {Quaternion} A reference to this quaternion.\n\t\t */\n\t\trotateTowards( q, step ) {\n\n\t\t\tconst angle = this.angleTo( q );\n\n\t\t\tif ( angle === 0 ) return this;\n\n\t\t\tconst t = Math.min( 1, step / angle );\n\n\t\t\tthis.slerp( q, t );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets this quaternion to the identity quaternion; that is, to the\n\t\t * quaternion that represents \"no rotation\".\n\t\t *\n\t\t * @return {Quaternion} A reference to this quaternion.\n\t\t */\n\t\tidentity() {\n\n\t\t\treturn this.set( 0, 0, 0, 1 );\n\n\t\t}\n\n\t\t/**\n\t\t * Inverts this quaternion via {@link Quaternion#conjugate}. The\n\t\t * quaternion is assumed to have unit length.\n\t\t *\n\t\t * @return {Quaternion} A reference to this quaternion.\n\t\t */\n\t\tinvert() {\n\n\t\t\treturn this.conjugate();\n\n\t\t}\n\n\t\t/**\n\t\t * Returns the rotational conjugate of this quaternion. The conjugate of a\n\t\t * quaternion represents the same rotation in the opposite direction about\n\t\t * the rotational axis.\n\t\t *\n\t\t * @return {Quaternion} A reference to this quaternion.\n\t\t */\n\t\tconjugate() {\n\n\t\t\tthis._x *= -1;\n\t\t\tthis._y *= -1;\n\t\t\tthis._z *= -1;\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Calculates the dot product of this quaternion and the given one.\n\t\t *\n\t\t * @param {Quaternion} v - The quaternion to compute the dot product with.\n\t\t * @return {number} The result of the dot product.\n\t\t */\n\t\tdot( v ) {\n\n\t\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\n\t\t}\n\n\t\t/**\n\t\t * Computes the squared Euclidean length (straight-line length) of this quaternion,\n\t\t * considered as a 4 dimensional vector. This can be useful if you are comparing the\n\t\t * lengths of two quaternions, as this is a slightly more efficient calculation than\n\t\t * {@link Quaternion#length}.\n\t\t *\n\t\t * @return {number} The squared Euclidean length.\n\t\t */\n\t\tlengthSq() {\n\n\t\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n\t\t}\n\n\t\t/**\n\t\t * Computes the Euclidean length (straight-line length) of this quaternion,\n\t\t * considered as a 4 dimensional vector.\n\t\t *\n\t\t * @return {number} The Euclidean length.\n\t\t */\n\t\tlength() {\n\n\t\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n\t\t}\n\n\t\t/**\n\t\t * Normalizes this quaternion - that is, calculated the quaternion that performs\n\t\t * the same rotation as this one, but has a length equal to `1`.\n\t\t *\n\t\t * @return {Quaternion} A reference to this quaternion.\n\t\t */\n\t\tnormalize() {\n\n\t\t\tlet l = this.length();\n\n\t\t\tif ( l === 0 ) {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = 0;\n\t\t\t\tthis._z = 0;\n\t\t\t\tthis._w = 1;\n\n\t\t\t} else {\n\n\t\t\t\tl = 1 / l;\n\n\t\t\t\tthis._x = this._x * l;\n\t\t\t\tthis._y = this._y * l;\n\t\t\t\tthis._z = this._z * l;\n\t\t\t\tthis._w = this._w * l;\n\n\t\t\t}\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Multiplies this quaternion by the given one.\n\t\t *\n\t\t * @param {Quaternion} q - The quaternion.\n\t\t * @return {Quaternion} A reference to this quaternion.\n\t\t */\n\t\tmultiply( q ) {\n\n\t\t\treturn this.multiplyQuaternions( this, q );\n\n\t\t}\n\n\t\t/**\n\t\t * Pre-multiplies this quaternion by the given one.\n\t\t *\n\t\t * @param {Quaternion} q - The quaternion.\n\t\t * @return {Quaternion} A reference to this quaternion.\n\t\t */\n\t\tpremultiply( q ) {\n\n\t\t\treturn this.multiplyQuaternions( q, this );\n\n\t\t}\n\n\t\t/**\n\t\t * Multiplies the given quaternions and stores the result in this instance.\n\t\t *\n\t\t * @param {Quaternion} a - The first quaternion.\n\t\t * @param {Quaternion} b - The second quaternion.\n\t\t * @return {Quaternion} A reference to this quaternion.\n\t\t */\n\t\tmultiplyQuaternions( a, b ) {\n\n\t\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\t\tconst qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\t\tconst qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n\t\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Performs a spherical linear interpolation between quaternions.\n\t\t *\n\t\t * @param {Quaternion} qb - The target quaternion.\n\t\t * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.\n\t\t * @return {Quaternion} A reference to this quaternion.\n\t\t */\n\t\tslerp( qb, t ) {\n\n\t\t\tif ( t === 0 ) return this;\n\t\t\tif ( t === 1 ) return this.copy( qb );\n\n\t\t\tconst x = this._x, y = this._y, z = this._z, w = this._w;\n\n\t\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\t\tlet cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\t\tthis._w = - qb._w;\n\t\t\t\tthis._x = - qb._x;\n\t\t\t\tthis._y = - qb._y;\n\t\t\t\tthis._z = - qb._z;\n\n\t\t\t\tcosHalfTheta = - cosHalfTheta;\n\n\t\t\t} else {\n\n\t\t\t\tthis.copy( qb );\n\n\t\t\t}\n\n\t\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\t\tthis._w = w;\n\t\t\t\tthis._x = x;\n\t\t\t\tthis._y = y;\n\t\t\t\tthis._z = z;\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tconst sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n\n\t\t\tif ( sqrSinHalfTheta <= Number.EPSILON ) {\n\n\t\t\t\tconst s = 1 - t;\n\t\t\t\tthis._w = s * w + t * this._w;\n\t\t\t\tthis._x = s * x + t * this._x;\n\t\t\t\tthis._y = s * y + t * this._y;\n\t\t\t\tthis._z = s * z + t * this._z;\n\n\t\t\t\tthis.normalize(); // normalize calls _onChangeCallback()\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tconst sinHalfTheta = Math.sqrt( sqrSinHalfTheta );\n\t\t\tconst halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\t\tconst ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Performs a spherical linear interpolation between the given quaternions\n\t\t * and stores the result in this quaternion.\n\t\t *\n\t\t * @param {Quaternion} qa - The source quaternion.\n\t\t * @param {Quaternion} qb - The target quaternion.\n\t\t * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.\n\t\t * @return {Quaternion} A reference to this quaternion.\n\t\t */\n\t\tslerpQuaternions( qa, qb, t ) {\n\n\t\t\treturn this.copy( qa ).slerp( qb, t );\n\n\t\t}\n\n\t\t/**\n\t\t * Sets this quaternion to a uniformly random, normalized quaternion.\n\t\t *\n\t\t * @return {Quaternion} A reference to this quaternion.\n\t\t */\n\t\trandom() {\n\n\t\t\t// Ken Shoemake\n\t\t\t// Uniform random rotations\n\t\t\t// D. Kirk, editor, Graphics Gems III, pages 124-132. Academic Press, New York, 1992.\n\n\t\t\tconst theta1 = 2 * Math.PI * Math.random();\n\t\t\tconst theta2 = 2 * Math.PI * Math.random();\n\n\t\t\tconst x0 = Math.random();\n\t\t\tconst r1 = Math.sqrt( 1 - x0 );\n\t\t\tconst r2 = Math.sqrt( x0 );\n\n\t\t\treturn this.set(\n\t\t\t\tr1 * Math.sin( theta1 ),\n\t\t\t\tr1 * Math.cos( theta1 ),\n\t\t\t\tr2 * Math.sin( theta2 ),\n\t\t\t\tr2 * Math.cos( theta2 ),\n\t\t\t);\n\n\t\t}\n\n\t\t/**\n\t\t * Returns `true` if this quaternion is equal with the given one.\n\t\t *\n\t\t * @param {Quaternion} quaternion - The quaternion to test for equality.\n\t\t * @return {boolean} Whether this quaternion is equal with the given one.\n\t\t */\n\t\tequals( quaternion ) {\n\n\t\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n\t\t}\n\n\t\t/**\n\t\t * Sets this quaternion's components from the given array.\n\t\t *\n\t\t * @param {Array<number>} array - An array holding the quaternion component values.\n\t\t * @param {number} [offset=0] - The offset into the array.\n\t\t * @return {Quaternion} A reference to this quaternion.\n\t\t */\n\t\tfromArray( array, offset = 0 ) {\n\n\t\t\tthis._x = array[ offset ];\n\t\t\tthis._y = array[ offset + 1 ];\n\t\t\tthis._z = array[ offset + 2 ];\n\t\t\tthis._w = array[ offset + 3 ];\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Writes the components of this quaternion to the given array. If no array is provided,\n\t\t * the method returns a new instance.\n\t\t *\n\t\t * @param {Array<number>} [array=[]] - The target array holding the quaternion components.\n\t\t * @param {number} [offset=0] - Index of the first element in the array.\n\t\t * @return {Array<number>} The quaternion components.\n\t\t */\n\t\ttoArray( array = [], offset = 0 ) {\n\n\t\t\tarray[ offset ] = this._x;\n\t\t\tarray[ offset + 1 ] = this._y;\n\t\t\tarray[ offset + 2 ] = this._z;\n\t\t\tarray[ offset + 3 ] = this._w;\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the components of this quaternion from the given buffer attribute.\n\t\t *\n\t\t * @param {BufferAttribute} attribute - The buffer attribute holding quaternion data.\n\t\t * @param {number} index - The index into the attribute.\n\t\t * @return {Quaternion} A reference to this quaternion.\n\t\t */\n\t\tfromBufferAttribute( attribute, index ) {\n\n\t\t\tthis._x = attribute.getX( index );\n\t\t\tthis._y = attribute.getY( index );\n\t\t\tthis._z = attribute.getZ( index );\n\t\t\tthis._w = attribute.getW( index );\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * This methods defines the serialization result of this class. Returns the\n\t\t * numerical elements of this quaternion in an array of format `[x, y, z, w]`.\n\t\t *\n\t\t * @return {Array<number>} The serialized quaternion.\n\t\t */\n\t\ttoJSON() {\n\n\t\t\treturn this.toArray();\n\n\t\t}\n\n\t\t_onChange( callback ) {\n\n\t\t\tthis._onChangeCallback = callback;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t_onChangeCallback() {}\n\n\t\t*[ Symbol.iterator ]() {\n\n\t\t\tyield this._x;\n\t\t\tyield this._y;\n\t\t\tyield this._z;\n\t\t\tyield this._w;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Class representing a 3D vector. A 3D vector is an ordered triplet of numbers\n\t * (labeled x, y and z), which can be used to represent a number of things, such as:\n\t *\n\t * - A point in 3D space.\n\t * - A direction and length in 3D space. In three.js the length will\n\t * always be the Euclidean distance(straight-line distance) from `(0, 0, 0)` to `(x, y, z)`\n\t * and the direction is also measured from `(0, 0, 0)` towards `(x, y, z)`.\n\t * - Any arbitrary ordered triplet of numbers.\n\t *\n\t * There are other things a 3D vector can be used to represent, such as\n\t * momentum vectors and so on, however these are the most\n\t * common uses in three.js.\n\t *\n\t * Iterating through a vector instance will yield its components `(x, y, z)` in\n\t * the corresponding order.\n\t * ```js\n\t * const a = new THREE.Vector3( 0, 1, 0 );\n\t *\n\t * //no arguments; will be initialised to (0, 0, 0)\n\t * const b = new THREE.Vector3( );\n\t *\n\t * const d = a.distanceTo( b );\n\t * ```\n\t */\n\tclass Vector3 {\n\n\t\t/**\n\t\t * Constructs a new 3D vector.\n\t\t *\n\t\t * @param {number} [x=0] - The x value of this vector.\n\t\t * @param {number} [y=0] - The y value of this vector.\n\t\t * @param {number} [z=0] - The z value of this vector.\n\t\t */\n\t\tconstructor( x = 0, y = 0, z = 0 ) {\n\n\t\t\t/**\n\t\t\t * This flag can be used for type testing.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @readonly\n\t\t\t * @default true\n\t\t\t */\n\t\t\tVector3.prototype.isVector3 = true;\n\n\t\t\t/**\n\t\t\t * The x value of this vector.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\tthis.x = x;\n\n\t\t\t/**\n\t\t\t * The y value of this vector.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\tthis.y = y;\n\n\t\t\t/**\n\t\t\t * The z value of this vector.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\tthis.z = z;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the vector components.\n\t\t *\n\t\t * @param {number} x - The value of the x component.\n\t\t * @param {number} y - The value of the y component.\n\t\t * @param {number} z - The value of the z component.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tset( x, y, z ) {\n\n\t\t\tif ( z === undefined ) z = this.z; // sprite.scale.set(x,y)\n\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the vector components to the same value.\n\t\t *\n\t\t * @param {number} scalar - The value to set for all vector components.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tsetScalar( scalar ) {\n\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\t\t\tthis.z = scalar;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the vector's x component to the given value\n\t\t *\n\t\t * @param {number} x - The value to set.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tsetX( x ) {\n\n\t\t\tthis.x = x;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the vector's y component to the given value\n\t\t *\n\t\t * @param {number} y - The value to set.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tsetY( y ) {\n\n\t\t\tthis.y = y;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the vector's z component to the given value\n\t\t *\n\t\t * @param {number} z - The value to set.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tsetZ( z ) {\n\n\t\t\tthis.z = z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Allows to set a vector component with an index.\n\t\t *\n\t\t * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.\n\t\t * @param {number} value - The value to set.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tsetComponent( index, value ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\tcase 2: this.z = value; break;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Returns the value of the vector component which matches the given index.\n\t\t *\n\t\t * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.\n\t\t * @return {number} A vector component value.\n\t\t */\n\t\tgetComponent( index ) {\n\n\t\t\tswitch ( index ) {\n\n\t\t\t\tcase 0: return this.x;\n\t\t\t\tcase 1: return this.y;\n\t\t\t\tcase 2: return this.z;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * Returns a new vector with copied values from this instance.\n\t\t *\n\t\t * @return {Vector3} A clone of this instance.\n\t\t */\n\t\tclone() {\n\n\t\t\treturn new this.constructor( this.x, this.y, this.z );\n\n\t\t}\n\n\t\t/**\n\t\t * Copies the values of the given vector to this instance.\n\t\t *\n\t\t * @param {Vector3} v - The vector to copy.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tcopy( v ) {\n\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\t\t\tthis.z = v.z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Adds the given vector to this instance.\n\t\t *\n\t\t * @param {Vector3} v - The vector to add.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tadd( v ) {\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\t\t\tthis.z += v.z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Adds the given scalar value to all components of this instance.\n\t\t *\n\t\t * @param {number} s - The scalar to add.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\taddScalar( s ) {\n\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\t\t\tthis.z += s;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Adds the given vectors and stores the result in this instance.\n\t\t *\n\t\t * @param {Vector3} a - The first vector.\n\t\t * @param {Vector3} b - The second vector.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\taddVectors( a, b ) {\n\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\t\t\tthis.z = a.z + b.z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Adds the given vector scaled by the given factor to this instance.\n\t\t *\n\t\t * @param {Vector3|Vector4} v - The vector.\n\t\t * @param {number} s - The factor that scales `v`.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\taddScaledVector( v, s ) {\n\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\t\t\tthis.z += v.z * s;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Subtracts the given vector from this instance.\n\t\t *\n\t\t * @param {Vector3} v - The vector to subtract.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tsub( v ) {\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\t\t\tthis.z -= v.z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Subtracts the given scalar value from all components of this instance.\n\t\t *\n\t\t * @param {number} s - The scalar to subtract.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tsubScalar( s ) {\n\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\t\t\tthis.z -= s;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Subtracts the given vectors and stores the result in this instance.\n\t\t *\n\t\t * @param {Vector3} a - The first vector.\n\t\t * @param {Vector3} b - The second vector.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tsubVectors( a, b ) {\n\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\t\t\tthis.z = a.z - b.z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Multiplies the given vector with this instance.\n\t\t *\n\t\t * @param {Vector3} v - The vector to multiply.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tmultiply( v ) {\n\n\t\t\tthis.x *= v.x;\n\t\t\tthis.y *= v.y;\n\t\t\tthis.z *= v.z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Multiplies the given scalar value with all components of this instance.\n\t\t *\n\t\t * @param {number} scalar - The scalar to multiply.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tmultiplyScalar( scalar ) {\n\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\t\t\tthis.z *= scalar;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Multiplies the given vectors and stores the result in this instance.\n\t\t *\n\t\t * @param {Vector3} a - The first vector.\n\t\t * @param {Vector3} b - The second vector.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tmultiplyVectors( a, b ) {\n\n\t\t\tthis.x = a.x * b.x;\n\t\t\tthis.y = a.y * b.y;\n\t\t\tthis.z = a.z * b.z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Applies the given Euler rotation to this vector.\n\t\t *\n\t\t * @param {Euler} euler - The Euler angles.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tapplyEuler( euler ) {\n\n\t\t\treturn this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );\n\n\t\t}\n\n\t\t/**\n\t\t * Applies a rotation specified by an axis and an angle to this vector.\n\t\t *\n\t\t * @param {Vector3} axis - A normalized vector representing the rotation axis.\n\t\t * @param {number} angle - The angle in radians.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tapplyAxisAngle( axis, angle ) {\n\n\t\t\treturn this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );\n\n\t\t}\n\n\t\t/**\n\t\t * Multiplies this vector with the given 3x3 matrix.\n\t\t *\n\t\t * @param {Matrix3} m - The 3x3 matrix.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tapplyMatrix3( m ) {\n\n\t\t\tconst x = this.x, y = this.y, z = this.z;\n\t\t\tconst e = m.elements;\n\n\t\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Multiplies this vector by the given normal matrix and normalizes\n\t\t * the result.\n\t\t *\n\t\t * @param {Matrix3} m - The normal matrix.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tapplyNormalMatrix( m ) {\n\n\t\t\treturn this.applyMatrix3( m ).normalize();\n\n\t\t}\n\n\t\t/**\n\t\t * Multiplies this vector (with an implicit 1 in the 4th dimension) by m, and\n\t\t * divides by perspective.\n\t\t *\n\t\t * @param {Matrix4} m - The matrix to apply.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tapplyMatrix4( m ) {\n\n\t\t\tconst x = this.x, y = this.y, z = this.z;\n\t\t\tconst e = m.elements;\n\n\t\t\tconst w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\n\n\t\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\n\t\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\n\t\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Applies the given Quaternion to this vector.\n\t\t *\n\t\t * @param {Quaternion} q - The Quaternion.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tapplyQuaternion( q ) {\n\n\t\t\t// quaternion q is assumed to have unit length\n\n\t\t\tconst vx = this.x, vy = this.y, vz = this.z;\n\t\t\tconst qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n\t\t\t// t = 2 * cross( q.xyz, v );\n\t\t\tconst tx = 2 * ( qy * vz - qz * vy );\n\t\t\tconst ty = 2 * ( qz * vx - qx * vz );\n\t\t\tconst tz = 2 * ( qx * vy - qy * vx );\n\n\t\t\t// v + q.w * t + cross( q.xyz, t );\n\t\t\tthis.x = vx + qw * tx + qy * tz - qz * ty;\n\t\t\tthis.y = vy + qw * ty + qz * tx - qx * tz;\n\t\t\tthis.z = vz + qw * tz + qx * ty - qy * tx;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Projects this vector from world space into the camera's normalized\n\t\t * device coordinate (NDC) space.\n\t\t *\n\t\t * @param {Camera} camera - The camera.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tproject( camera ) {\n\n\t\t\treturn this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );\n\n\t\t}\n\n\t\t/**\n\t\t * Unprojects this vector from the camera's normalized device coordinate (NDC)\n\t\t * space into world space.\n\t\t *\n\t\t * @param {Camera} camera - The camera.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tunproject( camera ) {\n\n\t\t\treturn this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );\n\n\t\t}\n\n\t\t/**\n\t\t * Transforms the direction of this vector by a matrix (the upper left 3 x 3\n\t\t * subset of the given 4x4 matrix and then normalizes the result.\n\t\t *\n\t\t * @param {Matrix4} m - The matrix.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\ttransformDirection( m ) {\n\n\t\t\t// input: THREE.Matrix4 affine matrix\n\t\t\t// vector interpreted as a direction\n\n\t\t\tconst x = this.x, y = this.y, z = this.z;\n\t\t\tconst e = m.elements;\n\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\t\treturn this.normalize();\n\n\t\t}\n\n\t\t/**\n\t\t * Divides this instance by the given vector.\n\t\t *\n\t\t * @param {Vector3} v - The vector to divide.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tdivide( v ) {\n\n\t\t\tthis.x /= v.x;\n\t\t\tthis.y /= v.y;\n\t\t\tthis.z /= v.z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Divides this vector by the given scalar.\n\t\t *\n\t\t * @param {number} scalar - The scalar to divide.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tdivideScalar( scalar ) {\n\n\t\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t\t}\n\n\t\t/**\n\t\t * If this vector's x, y or z value is greater than the given vector's x, y or z\n\t\t * value, replace that value with the corresponding min value.\n\t\t *\n\t\t * @param {Vector3} v - The vector.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tmin( v ) {\n\n\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\tthis.y = Math.min( this.y, v.y );\n\t\t\tthis.z = Math.min( this.z, v.z );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * If this vector's x, y or z value is less than the given vector's x, y or z\n\t\t * value, replace that value with the corresponding max value.\n\t\t *\n\t\t * @param {Vector3} v - The vector.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tmax( v ) {\n\n\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\tthis.y = Math.max( this.y, v.y );\n\t\t\tthis.z = Math.max( this.z, v.z );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * If this vector's x, y or z value is greater than the max vector's x, y or z\n\t\t * value, it is replaced by the corresponding value.\n\t\t * If this vector's x, y or z value is less than the min vector's x, y or z value,\n\t\t * it is replaced by the corresponding value.\n\t\t *\n\t\t * @param {Vector3} min - The minimum x, y and z values.\n\t\t * @param {Vector3} max - The maximum x, y and z values in the desired range.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tclamp( min, max ) {\n\n\t\t\t// assumes min < max, componentwise\n\n\t\t\tthis.x = clamp( this.x, min.x, max.x );\n\t\t\tthis.y = clamp( this.y, min.y, max.y );\n\t\t\tthis.z = clamp( this.z, min.z, max.z );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * If this vector's x, y or z values are greater than the max value, they are\n\t\t * replaced by the max value.\n\t\t * If this vector's x, y or z values are less than the min value, they are\n\t\t * replaced by the min value.\n\t\t *\n\t\t * @param {number} minVal - The minimum value the components will be clamped to.\n\t\t * @param {number} maxVal - The maximum value the components will be clamped to.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tclampScalar( minVal, maxVal ) {\n\n\t\t\tthis.x = clamp( this.x, minVal, maxVal );\n\t\t\tthis.y = clamp( this.y, minVal, maxVal );\n\t\t\tthis.z = clamp( this.z, minVal, maxVal );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * If this vector's length is greater than the max value, it is replaced by\n\t\t * the max value.\n\t\t * If this vector's length is less than the min value, it is replaced by the\n\t\t * min value.\n\t\t *\n\t\t * @param {number} min - The minimum value the vector length will be clamped to.\n\t\t * @param {number} max - The maximum value the vector length will be clamped to.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tclampLength( min, max ) {\n\n\t\t\tconst length = this.length();\n\n\t\t\treturn this.divideScalar( length || 1 ).multiplyScalar( clamp( length, min, max ) );\n\n\t\t}\n\n\t\t/**\n\t\t * The components of this vector are rounded down to the nearest integer value.\n\t\t *\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tfloor() {\n\n\t\t\tthis.x = Math.floor( this.x );\n\t\t\tthis.y = Math.floor( this.y );\n\t\t\tthis.z = Math.floor( this.z );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * The components of this vector are rounded up to the nearest integer value.\n\t\t *\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tceil() {\n\n\t\t\tthis.x = Math.ceil( this.x );\n\t\t\tthis.y = Math.ceil( this.y );\n\t\t\tthis.z = Math.ceil( this.z );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * The components of this vector are rounded to the nearest integer value\n\t\t *\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tround() {\n\n\t\t\tthis.x = Math.round( this.x );\n\t\t\tthis.y = Math.round( this.y );\n\t\t\tthis.z = Math.round( this.z );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * The components of this vector are rounded towards zero (up if negative,\n\t\t * down if positive) to an integer value.\n\t\t *\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\troundToZero() {\n\n\t\t\tthis.x = Math.trunc( this.x );\n\t\t\tthis.y = Math.trunc( this.y );\n\t\t\tthis.z = Math.trunc( this.z );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Inverts this vector - i.e. sets x = -x, y = -y and z = -z.\n\t\t *\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tnegate() {\n\n\t\t\tthis.x = - this.x;\n\t\t\tthis.y = - this.y;\n\t\t\tthis.z = - this.z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Calculates the dot product of the given vector with this instance.\n\t\t *\n\t\t * @param {Vector3} v - The vector to compute the dot product with.\n\t\t * @return {number} The result of the dot product.\n\t\t */\n\t\tdot( v ) {\n\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t\t}\n\n\t\t// TODO lengthSquared?\n\n\t\t/**\n\t\t * Computes the square of the Euclidean length (straight-line length) from\n\t\t * (0, 0, 0) to (x, y, z). If you are comparing the lengths of vectors, you should\n\t\t * compare the length squared instead as it is slightly more efficient to calculate.\n\t\t *\n\t\t * @return {number} The square length of this vector.\n\t\t */\n\t\tlengthSq() {\n\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t\t}\n\n\t\t/**\n\t\t * Computes the  Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z).\n\t\t *\n\t\t * @return {number} The length of this vector.\n\t\t */\n\t\tlength() {\n\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t\t}\n\n\t\t/**\n\t\t * Computes the Manhattan length of this vector.\n\t\t *\n\t\t * @return {number} The length of this vector.\n\t\t */\n\t\tmanhattanLength() {\n\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t\t}\n\n\t\t/**\n\t\t * Converts this vector to a unit vector - that is, sets it equal to a vector\n\t\t * with the same direction as this one, but with a vector length of `1`.\n\t\t *\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tnormalize() {\n\n\t\t\treturn this.divideScalar( this.length() || 1 );\n\n\t\t}\n\n\t\t/**\n\t\t * Sets this vector to a vector with the same direction as this one, but\n\t\t * with the specified length.\n\t\t *\n\t\t * @param {number} length - The new length of this vector.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tsetLength( length ) {\n\n\t\t\treturn this.normalize().multiplyScalar( length );\n\n\t\t}\n\n\t\t/**\n\t\t * Linearly interpolates between the given vector and this instance, where\n\t\t * alpha is the percent distance along the line - alpha = 0 will be this\n\t\t * vector, and alpha = 1 will be the given one.\n\t\t *\n\t\t * @param {Vector3} v - The vector to interpolate towards.\n\t\t * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tlerp( v, alpha ) {\n\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Linearly interpolates between the given vectors, where alpha is the percent\n\t\t * distance along the line - alpha = 0 will be first vector, and alpha = 1 will\n\t\t * be the second one. The result is stored in this instance.\n\t\t *\n\t\t * @param {Vector3} v1 - The first vector.\n\t\t * @param {Vector3} v2 - The second vector.\n\t\t * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tlerpVectors( v1, v2, alpha ) {\n\n\t\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\t\t\tthis.z = v1.z + ( v2.z - v1.z ) * alpha;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Calculates the cross product of the given vector with this instance.\n\t\t *\n\t\t * @param {Vector3} v - The vector to compute the cross product with.\n\t\t * @return {Vector3} The result of the cross product.\n\t\t */\n\t\tcross( v ) {\n\n\t\t\treturn this.crossVectors( this, v );\n\n\t\t}\n\n\t\t/**\n\t\t * Calculates the cross product of the given vectors and stores the result\n\t\t * in this instance.\n\t\t *\n\t\t * @param {Vector3} a - The first vector.\n\t\t * @param {Vector3} b - The second vector.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tcrossVectors( a, b ) {\n\n\t\t\tconst ax = a.x, ay = a.y, az = a.z;\n\t\t\tconst bx = b.x, by = b.y, bz = b.z;\n\n\t\t\tthis.x = ay * bz - az * by;\n\t\t\tthis.y = az * bx - ax * bz;\n\t\t\tthis.z = ax * by - ay * bx;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Projects this vector onto the given one.\n\t\t *\n\t\t * @param {Vector3} v - The vector to project to.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tprojectOnVector( v ) {\n\n\t\t\tconst denominator = v.lengthSq();\n\n\t\t\tif ( denominator === 0 ) return this.set( 0, 0, 0 );\n\n\t\t\tconst scalar = v.dot( this ) / denominator;\n\n\t\t\treturn this.copy( v ).multiplyScalar( scalar );\n\n\t\t}\n\n\t\t/**\n\t\t * Projects this vector onto a plane by subtracting this\n\t\t * vector projected onto the plane's normal from this vector.\n\t\t *\n\t\t * @param {Vector3} planeNormal - The plane normal.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tprojectOnPlane( planeNormal ) {\n\n\t\t\t_vector$c.copy( this ).projectOnVector( planeNormal );\n\n\t\t\treturn this.sub( _vector$c );\n\n\t\t}\n\n\t\t/**\n\t\t * Reflects this vector off a plane orthogonal to the given normal vector.\n\t\t *\n\t\t * @param {Vector3} normal - The (normalized) normal vector.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\treflect( normal ) {\n\n\t\t\treturn this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\n\t\t}\n\t\t/**\n\t\t * Returns the angle between the given vector and this instance in radians.\n\t\t *\n\t\t * @param {Vector3} v - The vector to compute the angle with.\n\t\t * @return {number} The angle in radians.\n\t\t */\n\t\tangleTo( v ) {\n\n\t\t\tconst denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );\n\n\t\t\tif ( denominator === 0 ) return Math.PI / 2;\n\n\t\t\tconst theta = this.dot( v ) / denominator;\n\n\t\t\t// clamp, to handle numerical problems\n\n\t\t\treturn Math.acos( clamp( theta, -1, 1 ) );\n\n\t\t}\n\n\t\t/**\n\t\t * Computes the distance from the given vector to this instance.\n\t\t *\n\t\t * @param {Vector3} v - The vector to compute the distance to.\n\t\t * @return {number} The distance.\n\t\t */\n\t\tdistanceTo( v ) {\n\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t\t}\n\n\t\t/**\n\t\t * Computes the squared distance from the given vector to this instance.\n\t\t * If you are just comparing the distance with another distance, you should compare\n\t\t * the distance squared instead as it is slightly more efficient to calculate.\n\t\t *\n\t\t * @param {Vector3} v - The vector to compute the squared distance to.\n\t\t * @return {number} The squared distance.\n\t\t */\n\t\tdistanceToSquared( v ) {\n\n\t\t\tconst dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\n\t\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t\t}\n\n\t\t/**\n\t\t * Computes the Manhattan distance from the given vector to this instance.\n\t\t *\n\t\t * @param {Vector3} v - The vector to compute the Manhattan distance to.\n\t\t * @return {number} The Manhattan distance.\n\t\t */\n\t\tmanhattanDistanceTo( v ) {\n\n\t\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the vector components from the given spherical coordinates.\n\t\t *\n\t\t * @param {Spherical} s - The spherical coordinates.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tsetFromSpherical( s ) {\n\n\t\t\treturn this.setFromSphericalCoords( s.radius, s.phi, s.theta );\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the vector components from the given spherical coordinates.\n\t\t *\n\t\t * @param {number} radius - The radius.\n\t\t * @param {number} phi - The phi angle in radians.\n\t\t * @param {number} theta - The theta angle in radians.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tsetFromSphericalCoords( radius, phi, theta ) {\n\n\t\t\tconst sinPhiRadius = Math.sin( phi ) * radius;\n\n\t\t\tthis.x = sinPhiRadius * Math.sin( theta );\n\t\t\tthis.y = Math.cos( phi ) * radius;\n\t\t\tthis.z = sinPhiRadius * Math.cos( theta );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the vector components from the given cylindrical coordinates.\n\t\t *\n\t\t * @param {Cylindrical} c - The cylindrical coordinates.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tsetFromCylindrical( c ) {\n\n\t\t\treturn this.setFromCylindricalCoords( c.radius, c.theta, c.y );\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the vector components from the given cylindrical coordinates.\n\t\t *\n\t\t * @param {number} radius - The radius.\n\t\t * @param {number} theta - The theta angle in radians.\n\t\t * @param {number} y - The y value.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tsetFromCylindricalCoords( radius, theta, y ) {\n\n\t\t\tthis.x = radius * Math.sin( theta );\n\t\t\tthis.y = y;\n\t\t\tthis.z = radius * Math.cos( theta );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the vector components to the position elements of the\n\t\t * given transformation matrix.\n\t\t *\n\t\t * @param {Matrix4} m - The 4x4 matrix.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tsetFromMatrixPosition( m ) {\n\n\t\t\tconst e = m.elements;\n\n\t\t\tthis.x = e[ 12 ];\n\t\t\tthis.y = e[ 13 ];\n\t\t\tthis.z = e[ 14 ];\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the vector components to the scale elements of the\n\t\t * given transformation matrix.\n\t\t *\n\t\t * @param {Matrix4} m - The 4x4 matrix.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tsetFromMatrixScale( m ) {\n\n\t\t\tconst sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\t\tconst sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\t\tconst sz = this.setFromMatrixColumn( m, 2 ).length();\n\n\t\t\tthis.x = sx;\n\t\t\tthis.y = sy;\n\t\t\tthis.z = sz;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the vector components from the specified matrix column.\n\t\t *\n\t\t * @param {Matrix4} m - The 4x4 matrix.\n\t\t * @param {number} index - The column index.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tsetFromMatrixColumn( m, index ) {\n\n\t\t\treturn this.fromArray( m.elements, index * 4 );\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the vector components from the specified matrix column.\n\t\t *\n\t\t * @param {Matrix3} m - The 3x3 matrix.\n\t\t * @param {number} index - The column index.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tsetFromMatrix3Column( m, index ) {\n\n\t\t\treturn this.fromArray( m.elements, index * 3 );\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the vector components from the given Euler angles.\n\t\t *\n\t\t * @param {Euler} e - The Euler angles to set.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tsetFromEuler( e ) {\n\n\t\t\tthis.x = e._x;\n\t\t\tthis.y = e._y;\n\t\t\tthis.z = e._z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the vector components from the RGB components of the\n\t\t * given color.\n\t\t *\n\t\t * @param {Color} c - The color to set.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tsetFromColor( c ) {\n\n\t\t\tthis.x = c.r;\n\t\t\tthis.y = c.g;\n\t\t\tthis.z = c.b;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Returns `true` if this vector is equal with the given one.\n\t\t *\n\t\t * @param {Vector3} v - The vector to test for equality.\n\t\t * @return {boolean} Whether this vector is equal with the given one.\n\t\t */\n\t\tequals( v ) {\n\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t\t}\n\n\t\t/**\n\t\t * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`\n\t\t * and z value to be `array[ offset + 2 ]`.\n\t\t *\n\t\t * @param {Array<number>} array - An array holding the vector component values.\n\t\t * @param {number} [offset=0] - The offset into the array.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tfromArray( array, offset = 0 ) {\n\n\t\t\tthis.x = array[ offset ];\n\t\t\tthis.y = array[ offset + 1 ];\n\t\t\tthis.z = array[ offset + 2 ];\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Writes the components of this vector to the given array. If no array is provided,\n\t\t * the method returns a new instance.\n\t\t *\n\t\t * @param {Array<number>} [array=[]] - The target array holding the vector components.\n\t\t * @param {number} [offset=0] - Index of the first element in the array.\n\t\t * @return {Array<number>} The vector components.\n\t\t */\n\t\ttoArray( array = [], offset = 0 ) {\n\n\t\t\tarray[ offset ] = this.x;\n\t\t\tarray[ offset + 1 ] = this.y;\n\t\t\tarray[ offset + 2 ] = this.z;\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the components of this vector from the given buffer attribute.\n\t\t *\n\t\t * @param {BufferAttribute} attribute - The buffer attribute holding vector data.\n\t\t * @param {number} index - The index into the attribute.\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\tfromBufferAttribute( attribute, index ) {\n\n\t\t\tthis.x = attribute.getX( index );\n\t\t\tthis.y = attribute.getY( index );\n\t\t\tthis.z = attribute.getZ( index );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets each component of this vector to a pseudo-random value between `0` and\n\t\t * `1`, excluding `1`.\n\t\t *\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\trandom() {\n\n\t\t\tthis.x = Math.random();\n\t\t\tthis.y = Math.random();\n\t\t\tthis.z = Math.random();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets this vector to a uniformly random point on a unit sphere.\n\t\t *\n\t\t * @return {Vector3} A reference to this vector.\n\t\t */\n\t\trandomDirection() {\n\n\t\t\t// https://mathworld.wolfram.com/SpherePointPicking.html\n\n\t\t\tconst theta = Math.random() * Math.PI * 2;\n\t\t\tconst u = Math.random() * 2 - 1;\n\t\t\tconst c = Math.sqrt( 1 - u * u );\n\n\t\t\tthis.x = c * Math.cos( theta );\n\t\t\tthis.y = u;\n\t\t\tthis.z = c * Math.sin( theta );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t*[ Symbol.iterator ]() {\n\n\t\t\tyield this.x;\n\t\t\tyield this.y;\n\t\t\tyield this.z;\n\n\t\t}\n\n\t}\n\n\tconst _vector$c = /*@__PURE__*/ new Vector3();\n\tconst _quaternion$4 = /*@__PURE__*/ new Quaternion();\n\n\t/**\n\t * Represents a 3x3 matrix.\n\t *\n\t * A Note on Row-Major and Column-Major Ordering:\n\t *\n\t * The constructor and {@link Matrix3#set} method take arguments in\n\t * [row-major]{@link https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order}\n\t * order, while internally they are stored in the {@link Matrix3#elements} array in column-major order.\n\t * This means that calling:\n\t * ```js\n\t * const m = new THREE.Matrix();\n\t * m.set( 11, 12, 13,\n\t *        21, 22, 23,\n\t *        31, 32, 33 );\n\t * ```\n\t * will result in the elements array containing:\n\t * ```js\n\t * m.elements = [ 11, 21, 31,\n\t *                12, 22, 32,\n\t *                13, 23, 33 ];\n\t * ```\n\t * and internally all calculations are performed using column-major ordering.\n\t * However, as the actual ordering makes no difference mathematically and\n\t * most people are used to thinking about matrices in row-major order, the\n\t * three.js documentation shows matrices in row-major order. Just bear in\n\t * mind that if you are reading the source code, you'll have to take the\n\t * transpose of any matrices outlined here to make sense of the calculations.\n\t */\n\tclass Matrix3 {\n\n\t\t/**\n\t\t * Constructs a new 3x3 matrix. The arguments are supposed to be\n\t\t * in row-major order. If no arguments are provided, the constructor\n\t\t * initializes the matrix as an identity matrix.\n\t\t *\n\t\t * @param {number} [n11] - 1-1 matrix element.\n\t\t * @param {number} [n12] - 1-2 matrix element.\n\t\t * @param {number} [n13] - 1-3 matrix element.\n\t\t * @param {number} [n21] - 2-1 matrix element.\n\t\t * @param {number} [n22] - 2-2 matrix element.\n\t\t * @param {number} [n23] - 2-3 matrix element.\n\t\t * @param {number} [n31] - 3-1 matrix element.\n\t\t * @param {number} [n32] - 3-2 matrix element.\n\t\t * @param {number} [n33] - 3-3 matrix element.\n\t\t */\n\t\tconstructor( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\t\t/**\n\t\t\t * This flag can be used for type testing.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @readonly\n\t\t\t * @default true\n\t\t\t */\n\t\t\tMatrix3.prototype.isMatrix3 = true;\n\n\t\t\t/**\n\t\t\t * A column-major list of matrix values.\n\t\t\t *\n\t\t\t * @type {Array<number>}\n\t\t\t */\n\t\t\tthis.elements = [\n\n\t\t\t\t1, 0, 0,\n\t\t\t\t0, 1, 0,\n\t\t\t\t0, 0, 1\n\n\t\t\t];\n\n\t\t\tif ( n11 !== undefined ) {\n\n\t\t\t\tthis.set( n11, n12, n13, n21, n22, n23, n31, n32, n33 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the elements of the matrix.The arguments are supposed to be\n\t\t * in row-major order.\n\t\t *\n\t\t * @param {number} [n11] - 1-1 matrix element.\n\t\t * @param {number} [n12] - 1-2 matrix element.\n\t\t * @param {number} [n13] - 1-3 matrix element.\n\t\t * @param {number} [n21] - 2-1 matrix element.\n\t\t * @param {number} [n22] - 2-2 matrix element.\n\t\t * @param {number} [n23] - 2-3 matrix element.\n\t\t * @param {number} [n31] - 3-1 matrix element.\n\t\t * @param {number} [n32] - 3-2 matrix element.\n\t\t * @param {number} [n33] - 3-3 matrix element.\n\t\t * @return {Matrix3} A reference to this matrix.\n\t\t */\n\t\tset( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\t\tconst te = this.elements;\n\n\t\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets this matrix to the 3x3 identity matrix.\n\t\t *\n\t\t * @return {Matrix3} A reference to this matrix.\n\t\t */\n\t\tidentity() {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0,\n\t\t\t\t0, 1, 0,\n\t\t\t\t0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Copies the values of the given matrix to this instance.\n\t\t *\n\t\t * @param {Matrix3} m - The matrix to copy.\n\t\t * @return {Matrix3} A reference to this matrix.\n\t\t */\n\t\tcopy( m ) {\n\n\t\t\tconst te = this.elements;\n\t\t\tconst me = m.elements;\n\n\t\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];\n\t\t\tte[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];\n\t\t\tte[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Extracts the basis of this matrix into the three axis vectors provided.\n\t\t *\n\t\t * @param {Vector3} xAxis - The basis's x axis.\n\t\t * @param {Vector3} yAxis - The basis's y axis.\n\t\t * @param {Vector3} zAxis - The basis's z axis.\n\t\t * @return {Matrix3} A reference to this matrix.\n\t\t */\n\t\textractBasis( xAxis, yAxis, zAxis ) {\n\n\t\t\txAxis.setFromMatrix3Column( this, 0 );\n\t\t\tyAxis.setFromMatrix3Column( this, 1 );\n\t\t\tzAxis.setFromMatrix3Column( this, 2 );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Set this matrix to the upper 3x3 matrix of the given 4x4 matrix.\n\t\t *\n\t\t * @param {Matrix4} m - The 4x4 matrix.\n\t\t * @return {Matrix3} A reference to this matrix.\n\t\t */\n\t\tsetFromMatrix4( m ) {\n\n\t\t\tconst me = m.elements;\n\n\t\t\tthis.set(\n\n\t\t\t\tme[ 0 ], me[ 4 ], me[ 8 ],\n\t\t\t\tme[ 1 ], me[ 5 ], me[ 9 ],\n\t\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Post-multiplies this matrix by the given 3x3 matrix.\n\t\t *\n\t\t * @param {Matrix3} m - The matrix to multiply with.\n\t\t * @return {Matrix3} A reference to this matrix.\n\t\t */\n\t\tmultiply( m ) {\n\n\t\t\treturn this.multiplyMatrices( this, m );\n\n\t\t}\n\n\t\t/**\n\t\t * Pre-multiplies this matrix by the given 3x3 matrix.\n\t\t *\n\t\t * @param {Matrix3} m - The matrix to multiply with.\n\t\t * @return {Matrix3} A reference to this matrix.\n\t\t */\n\t\tpremultiply( m ) {\n\n\t\t\treturn this.multiplyMatrices( m, this );\n\n\t\t}\n\n\t\t/**\n\t\t * Multiples the given 3x3 matrices and stores the result\n\t\t * in this matrix.\n\t\t *\n\t\t * @param {Matrix3} a - The first matrix.\n\t\t * @param {Matrix3} b - The second matrix.\n\t\t * @return {Matrix3} A reference to this matrix.\n\t\t */\n\t\tmultiplyMatrices( a, b ) {\n\n\t\t\tconst ae = a.elements;\n\t\t\tconst be = b.elements;\n\t\t\tconst te = this.elements;\n\n\t\t\tconst a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];\n\t\t\tconst a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];\n\t\t\tconst a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];\n\n\t\t\tconst b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];\n\t\t\tconst b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];\n\t\t\tconst b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];\n\n\t\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;\n\t\t\tte[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;\n\t\t\tte[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;\n\n\t\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;\n\t\t\tte[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;\n\t\t\tte[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;\n\n\t\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;\n\t\t\tte[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;\n\t\t\tte[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Multiplies every component of the matrix by the given scalar.\n\t\t *\n\t\t * @param {number} s - The scalar.\n\t\t * @return {Matrix3} A reference to this matrix.\n\t\t */\n\t\tmultiplyScalar( s ) {\n\n\t\t\tconst te = this.elements;\n\n\t\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Computes and returns the determinant of this matrix.\n\t\t *\n\t\t * @return {number} The determinant.\n\t\t */\n\t\tdeterminant() {\n\n\t\t\tconst te = this.elements;\n\n\t\t\tconst a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\n\t\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n\t\t}\n\n\t\t/**\n\t\t * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.\n\t\t * You can not invert with a determinant of zero. If you attempt this, the method produces\n\t\t * a zero matrix instead.\n\t\t *\n\t\t * @return {Matrix3} A reference to this matrix.\n\t\t */\n\t\tinvert() {\n\n\t\t\tconst te = this.elements,\n\n\t\t\t\tn11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],\n\t\t\t\tn12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],\n\t\t\t\tn13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],\n\n\t\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\t\tt13 = n23 * n12 - n22 * n13,\n\n\t\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\n\t\t\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n\n\t\t\tconst detInv = 1 / det;\n\n\t\t\tte[ 0 ] = t11 * detInv;\n\t\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\n\t\t\tte[ 3 ] = t12 * detInv;\n\t\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\n\t\t\tte[ 6 ] = t13 * detInv;\n\t\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Transposes this matrix in place.\n\t\t *\n\t\t * @return {Matrix3} A reference to this matrix.\n\t\t */\n\t\ttranspose() {\n\n\t\t\tlet tmp;\n\t\t\tconst m = this.elements;\n\n\t\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Computes the normal matrix which is the inverse transpose of the upper\n\t\t * left 3x3 portion of the given 4x4 matrix.\n\t\t *\n\t\t * @param {Matrix4} matrix4 - The 4x4 matrix.\n\t\t * @return {Matrix3} A reference to this matrix.\n\t\t */\n\t\tgetNormalMatrix( matrix4 ) {\n\n\t\t\treturn this.setFromMatrix4( matrix4 ).invert().transpose();\n\n\t\t}\n\n\t\t/**\n\t\t * Transposes this matrix into the supplied array, and returns itself unchanged.\n\t\t *\n\t\t * @param {Array<number>} r - An array to store the transposed matrix elements.\n\t\t * @return {Matrix3} A reference to this matrix.\n\t\t */\n\t\ttransposeIntoArray( r ) {\n\n\t\t\tconst m = this.elements;\n\n\t\t\tr[ 0 ] = m[ 0 ];\n\t\t\tr[ 1 ] = m[ 3 ];\n\t\t\tr[ 2 ] = m[ 6 ];\n\t\t\tr[ 3 ] = m[ 1 ];\n\t\t\tr[ 4 ] = m[ 4 ];\n\t\t\tr[ 5 ] = m[ 7 ];\n\t\t\tr[ 6 ] = m[ 2 ];\n\t\t\tr[ 7 ] = m[ 5 ];\n\t\t\tr[ 8 ] = m[ 8 ];\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the UV transform matrix from offset, repeat, rotation, and center.\n\t\t *\n\t\t * @param {number} tx - Offset x.\n\t\t * @param {number} ty - Offset y.\n\t\t * @param {number} sx - Repeat x.\n\t\t * @param {number} sy - Repeat y.\n\t\t * @param {number} rotation - Rotation, in radians. Positive values rotate counterclockwise.\n\t\t * @param {number} cx - Center x of rotation.\n\t\t * @param {number} cy - Center y of rotation\n\t\t * @return {Matrix3} A reference to this matrix.\n\t\t */\n\t\tsetUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {\n\n\t\t\tconst c = Math.cos( rotation );\n\t\t\tconst s = Math.sin( rotation );\n\n\t\t\tthis.set(\n\t\t\t\tsx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,\n\t\t\t\t- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,\n\t\t\t\t0, 0, 1\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Scales this matrix with the given scalar values.\n\t\t *\n\t\t * @param {number} sx - The amount to scale in the X axis.\n\t\t * @param {number} sy - The amount to scale in the Y axis.\n\t\t * @return {Matrix3} A reference to this matrix.\n\t\t */\n\t\tscale( sx, sy ) {\n\n\t\t\tthis.premultiply( _m3.makeScale( sx, sy ) );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Rotates this matrix by the given angle.\n\t\t *\n\t\t * @param {number} theta - The rotation in radians.\n\t\t * @return {Matrix3} A reference to this matrix.\n\t\t */\n\t\trotate( theta ) {\n\n\t\t\tthis.premultiply( _m3.makeRotation( - theta ) );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Translates this matrix by the given scalar values.\n\t\t *\n\t\t * @param {number} tx - The amount to translate in the X axis.\n\t\t * @param {number} ty - The amount to translate in the Y axis.\n\t\t * @return {Matrix3} A reference to this matrix.\n\t\t */\n\t\ttranslate( tx, ty ) {\n\n\t\t\tthis.premultiply( _m3.makeTranslation( tx, ty ) );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t// for 2D Transforms\n\n\t\t/**\n\t\t * Sets this matrix as a 2D translation transform.\n\t\t *\n\t\t * @param {number|Vector2} x - The amount to translate in the X axis or alternatively a translation vector.\n\t\t * @param {number} y - The amount to translate in the Y axis.\n\t\t * @return {Matrix3} A reference to this matrix.\n\t\t */\n\t\tmakeTranslation( x, y ) {\n\n\t\t\tif ( x.isVector2 ) {\n\n\t\t\t\tthis.set(\n\n\t\t\t\t\t1, 0, x.x,\n\t\t\t\t\t0, 1, x.y,\n\t\t\t\t\t0, 0, 1\n\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tthis.set(\n\n\t\t\t\t\t1, 0, x,\n\t\t\t\t\t0, 1, y,\n\t\t\t\t\t0, 0, 1\n\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets this matrix as a 2D rotational transformation.\n\t\t *\n\t\t * @param {number} theta - The rotation in radians.\n\t\t * @return {Matrix3} A reference to this matrix.\n\t\t */\n\t\tmakeRotation( theta ) {\n\n\t\t\t// counterclockwise\n\n\t\t\tconst c = Math.cos( theta );\n\t\t\tconst s = Math.sin( theta );\n\n\t\t\tthis.set(\n\n\t\t\t\tc, - s, 0,\n\t\t\t\ts, c, 0,\n\t\t\t\t0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets this matrix as a 2D scale transform.\n\t\t *\n\t\t * @param {number} x - The amount to scale in the X axis.\n\t\t * @param {number} y - The amount to scale in the Y axis.\n\t\t * @return {Matrix3} A reference to this matrix.\n\t\t */\n\t\tmakeScale( x, y ) {\n\n\t\t\tthis.set(\n\n\t\t\t\tx, 0, 0,\n\t\t\t\t0, y, 0,\n\t\t\t\t0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Returns `true` if this matrix is equal with the given one.\n\t\t *\n\t\t * @param {Matrix3} matrix - The matrix to test for equality.\n\t\t * @return {boolean} Whether this matrix is equal with the given one.\n\t\t */\n\t\tequals( matrix ) {\n\n\t\t\tconst te = this.elements;\n\t\t\tconst me = matrix.elements;\n\n\t\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the elements of the matrix from the given array.\n\t\t *\n\t\t * @param {Array<number>} array - The matrix elements in column-major order.\n\t\t * @param {number} [offset=0] - Index of the first element in the array.\n\t\t * @return {Matrix3} A reference to this matrix.\n\t\t */\n\t\tfromArray( array, offset = 0 ) {\n\n\t\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Writes the elements of this matrix to the given array. If no array is provided,\n\t\t * the method returns a new instance.\n\t\t *\n\t\t * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.\n\t\t * @param {number} [offset=0] - Index of the first element in the array.\n\t\t * @return {Array<number>} The matrix elements in column-major order.\n\t\t */\n\t\ttoArray( array = [], offset = 0 ) {\n\n\t\t\tconst te = this.elements;\n\n\t\t\tarray[ offset ] = te[ 0 ];\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\n\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\n\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\t\tarray[ offset + 8 ] = te[ 8 ];\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\t/**\n\t\t * Returns a matrix with copied values from this instance.\n\t\t *\n\t\t * @return {Matrix3} A clone of this instance.\n\t\t */\n\t\tclone() {\n\n\t\t\treturn new this.constructor().fromArray( this.elements );\n\n\t\t}\n\n\t}\n\n\tconst _m3 = /*@__PURE__*/ new Matrix3();\n\n\tfunction createElementNS( name ) {\n\n\t\treturn document.createElementNS( 'http://www.w3.org/1999/xhtml', name );\n\n\t}\n\n\tfunction SRGBToLinear( c ) {\n\n\t\treturn ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n\n\t}\n\n\tlet _canvas;\n\n\t/**\n\t * A class containing utility functions for images.\n\t *\n\t * @hideconstructor\n\t */\n\tclass ImageUtils {\n\n\t\t/**\n\t\t * Returns a data URI containing a representation of the given image.\n\t\t *\n\t\t * @param {(HTMLImageElement|HTMLCanvasElement)} image - The image object.\n\t\t * @param {string} [type='image/png'] - Indicates the image format.\n\t\t * @return {string} The data URI.\n\t\t */\n\t\tstatic getDataURL( image, type = 'image/png' ) {\n\n\t\t\tif ( /^data:/i.test( image.src ) ) {\n\n\t\t\t\treturn image.src;\n\n\t\t\t}\n\n\t\t\tif ( typeof HTMLCanvasElement === 'undefined' ) {\n\n\t\t\t\treturn image.src;\n\n\t\t\t}\n\n\t\t\tlet canvas;\n\n\t\t\tif ( image instanceof HTMLCanvasElement ) {\n\n\t\t\t\tcanvas = image;\n\n\t\t\t} else {\n\n\t\t\t\tif ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );\n\n\t\t\t\t_canvas.width = image.width;\n\t\t\t\t_canvas.height = image.height;\n\n\t\t\t\tconst context = _canvas.getContext( '2d' );\n\n\t\t\t\tif ( image instanceof ImageData ) {\n\n\t\t\t\t\tcontext.putImageData( image, 0, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\t\t}\n\n\t\t\t\tcanvas = _canvas;\n\n\t\t\t}\n\n\t\t\treturn canvas.toDataURL( type );\n\n\t\t}\n\n\t\t/**\n\t\t * Converts the given sRGB image data to linear color space.\n\t\t *\n\t\t * @param {(HTMLImageElement|HTMLCanvasElement|ImageBitmap|Object)} image - The image object.\n\t\t * @return {HTMLCanvasElement|Object} The converted image.\n\t\t */\n\t\tstatic sRGBToLinear( image ) {\n\n\t\t\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {\n\n\t\t\t\tconst canvas = createElementNS( 'canvas' );\n\n\t\t\t\tcanvas.width = image.width;\n\t\t\t\tcanvas.height = image.height;\n\n\t\t\t\tconst context = canvas.getContext( '2d' );\n\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\t\tconst imageData = context.getImageData( 0, 0, image.width, image.height );\n\t\t\t\tconst data = imageData.data;\n\n\t\t\t\tfor ( let i = 0; i < data.length; i ++ ) {\n\n\t\t\t\t\tdata[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255;\n\n\t\t\t\t}\n\n\t\t\t\tcontext.putImageData( imageData, 0, 0 );\n\n\t\t\t\treturn canvas;\n\n\t\t\t} else if ( image.data ) {\n\n\t\t\t\tconst data = image.data.slice( 0 );\n\n\t\t\t\tfor ( let i = 0; i < data.length; i ++ ) {\n\n\t\t\t\t\tif ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {\n\n\t\t\t\t\t\tdata[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// assuming float\n\n\t\t\t\t\t\tdata[ i ] = SRGBToLinear( data[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tdata: data,\n\t\t\t\t\twidth: image.width,\n\t\t\t\t\theight: image.height\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );\n\t\t\t\treturn image;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tlet _sourceId = 0;\n\n\t/**\n\t * Represents the data source of a texture.\n\t *\n\t * The main purpose of this class is to decouple the data definition from the texture\n\t * definition so the same data can be used with multiple texture instances.\n\t */\n\tclass Source {\n\n\t\t/**\n\t\t * Constructs a new video texture.\n\t\t *\n\t\t * @param {any} [data=null] - The data definition of a texture.\n\t\t */\n\t\tconstructor( data = null ) {\n\n\t\t\t/**\n\t\t\t * This flag can be used for type testing.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @readonly\n\t\t\t * @default true\n\t\t\t */\n\t\t\tthis.isSource = true;\n\n\t\t\t/**\n\t\t\t * The ID of the source.\n\t\t\t *\n\t\t\t * @name Source#id\n\t\t\t * @type {number}\n\t\t\t * @readonly\n\t\t\t */\n\t\t\tObject.defineProperty( this, 'id', { value: _sourceId ++ } );\n\n\t\t\t/**\n\t\t\t * The UUID of the source.\n\t\t\t *\n\t\t\t * @type {string}\n\t\t\t * @readonly\n\t\t\t */\n\t\t\tthis.uuid = generateUUID();\n\n\t\t\t/**\n\t\t\t * The data definition of a texture.\n\t\t\t *\n\t\t\t * @type {any}\n\t\t\t */\n\t\t\tthis.data = data;\n\n\t\t\t/**\n\t\t\t * This property is only relevant when {@link Source#needsUpdate} is set to `true` and\n\t\t\t * provides more control on how texture data should be processed. When `dataReady` is set\n\t\t\t * to `false`, the engine performs the memory allocation (if necessary) but does not transfer\n\t\t\t * the data into the GPU memory.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @default true\n\t\t\t */\n\t\t\tthis.dataReady = true;\n\n\t\t\t/**\n\t\t\t * This starts at `0` and counts how many times {@link Source#needsUpdate} is set to `true`.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @readonly\n\t\t\t * @default 0\n\t\t\t */\n\t\t\tthis.version = 0;\n\n\t\t}\n\n\t\tgetSize( target ) {\n\n\t\t\tconst data = this.data;\n\n\t\t\tif ( data instanceof HTMLVideoElement ) {\n\n\t\t\t\ttarget.set( data.videoWidth, data.videoHeight );\n\n\t\t\t} else if ( data !== null ) {\n\n\t\t\t\ttarget.set( data.width, data.height, data.depth || 0 );\n\n\t\t\t} else {\n\n\t\t\t\ttarget.set( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t\treturn target;\n\n\t\t}\n\n\t\t/**\n\t\t * When the property is set to `true`, the engine allocates the memory\n\t\t * for the texture (if necessary) and triggers the actual texture upload\n\t\t * to the GPU next time the source is used.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t * @param {boolean} value\n\t\t */\n\t\tset needsUpdate( value ) {\n\n\t\t\tif ( value === true ) this.version ++;\n\n\t\t}\n\n\t\t/**\n\t\t * Serializes the source into JSON.\n\t\t *\n\t\t * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.\n\t\t * @return {Object} A JSON object representing the serialized source.\n\t\t * @see {@link ObjectLoader#parse}\n\t\t */\n\t\ttoJSON( meta ) {\n\n\t\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\t\tif ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) {\n\n\t\t\t\treturn meta.images[ this.uuid ];\n\n\t\t\t}\n\n\t\t\tconst output = {\n\t\t\t\tuuid: this.uuid,\n\t\t\t\turl: ''\n\t\t\t};\n\n\t\t\tconst data = this.data;\n\n\t\t\tif ( data !== null ) {\n\n\t\t\t\tlet url;\n\n\t\t\t\tif ( Array.isArray( data ) ) {\n\n\t\t\t\t\t// cube texture\n\n\t\t\t\t\turl = [];\n\n\t\t\t\t\tfor ( let i = 0, l = data.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( data[ i ].isDataTexture ) {\n\n\t\t\t\t\t\t\turl.push( serializeImage( data[ i ].image ) );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\turl.push( serializeImage( data[ i ] ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// texture\n\n\t\t\t\t\turl = serializeImage( data );\n\n\t\t\t\t}\n\n\t\t\t\toutput.url = url;\n\n\t\t\t}\n\n\t\t\tif ( ! isRootObject ) {\n\n\t\t\t\tmeta.images[ this.uuid ] = output;\n\n\t\t\t}\n\n\t\t\treturn output;\n\n\t\t}\n\n\t}\n\n\tfunction serializeImage( image ) {\n\n\t\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {\n\n\t\t\t// default images\n\n\t\t\treturn ImageUtils.getDataURL( image );\n\n\t\t} else {\n\n\t\t\tif ( image.data ) {\n\n\t\t\t\t// images of DataTexture\n\n\t\t\t\treturn {\n\t\t\t\t\tdata: Array.from( image.data ),\n\t\t\t\t\twidth: image.width,\n\t\t\t\t\theight: image.height,\n\t\t\t\t\ttype: image.data.constructor.name\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.Texture: Unable to serialize Texture.' );\n\t\t\t\treturn {};\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tlet _textureId = 0;\n\n\tconst _tempVec3 = /*@__PURE__*/ new Vector3();\n\n\t/**\n\t * Base class for all textures.\n\t *\n\t * Note: After the initial use of a texture, its dimensions, format, and type\n\t * cannot be changed. Instead, call {@link Texture#dispose} on the texture and instantiate a new one.\n\t *\n\t * @augments EventDispatcher\n\t */\n\tclass Texture extends EventDispatcher {\n\n\t\t/**\n\t\t * Constructs a new texture.\n\t\t *\n\t\t * @param {?Object} [image=Texture.DEFAULT_IMAGE] - The image holding the texture data.\n\t\t * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.\n\t\t * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.\n\t\t * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.\n\t\t * @param {number} [magFilter=LinearFilter] - The mag filter value.\n\t\t * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.\n\t\t * @param {number} [format=RGBAFormat] - The texture format.\n\t\t * @param {number} [type=UnsignedByteType] - The texture type.\n\t\t * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.\n\t\t * @param {string} [colorSpace=NoColorSpace] - The color space.\n\t\t */\n\t\tconstructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace ) {\n\n\t\t\tsuper();\n\n\t\t\t/**\n\t\t\t * This flag can be used for type testing.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @readonly\n\t\t\t * @default true\n\t\t\t */\n\t\t\tthis.isTexture = true;\n\n\t\t\t/**\n\t\t\t * The ID of the texture.\n\t\t\t *\n\t\t\t * @name Texture#id\n\t\t\t * @type {number}\n\t\t\t * @readonly\n\t\t\t */\n\t\t\tObject.defineProperty( this, 'id', { value: _textureId ++ } );\n\n\t\t\t/**\n\t\t\t * The UUID of the material.\n\t\t\t *\n\t\t\t * @type {string}\n\t\t\t * @readonly\n\t\t\t */\n\t\t\tthis.uuid = generateUUID();\n\n\t\t\t/**\n\t\t\t * The name of the material.\n\t\t\t *\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.name = '';\n\n\t\t\t/**\n\t\t\t * The data definition of a texture. A reference to the data source can be\n\t\t\t * shared across textures. This is often useful in context of spritesheets\n\t\t\t * where multiple textures render the same data but with different texture\n\t\t\t * transformations.\n\t\t\t *\n\t\t\t * @type {Source}\n\t\t\t */\n\t\t\tthis.source = new Source( image );\n\n\t\t\t/**\n\t\t\t * An array holding user-defined mipmaps.\n\t\t\t *\n\t\t\t * @type {Array<Object>}\n\t\t\t */\n\t\t\tthis.mipmaps = [];\n\n\t\t\t/**\n\t\t\t * How the texture is applied to the object. The value `UVMapping`\n\t\t\t * is the default, where texture or uv coordinates are used to apply the map.\n\t\t\t *\n\t\t\t * @type {(UVMapping|CubeReflectionMapping|CubeRefractionMapping|EquirectangularReflectionMapping|EquirectangularRefractionMapping|CubeUVReflectionMapping)}\n\t\t\t * @default UVMapping\n\t\t\t*/\n\t\t\tthis.mapping = mapping;\n\n\t\t\t/**\n\t\t\t * Lets you select the uv attribute to map the texture to. `0` for `uv`,\n\t\t\t * `1` for `uv1`, `2` for `uv2` and `3` for `uv3`.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default 0\n\t\t\t */\n\t\t\tthis.channel = 0;\n\n\t\t\t/**\n\t\t\t * This defines how the texture is wrapped horizontally and corresponds to\n\t\t\t * *U* in UV mapping.\n\t\t\t *\n\t\t\t * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}\n\t\t\t * @default ClampToEdgeWrapping\n\t\t\t */\n\t\t\tthis.wrapS = wrapS;\n\n\t\t\t/**\n\t\t\t * This defines how the texture is wrapped horizontally and corresponds to\n\t\t\t * *V* in UV mapping.\n\t\t\t *\n\t\t\t * @type {(RepeatWrapping|ClampToEdgeWrapping|MirroredRepeatWrapping)}\n\t\t\t * @default ClampToEdgeWrapping\n\t\t\t */\n\t\t\tthis.wrapT = wrapT;\n\n\t\t\t/**\n\t\t\t * How the texture is sampled when a texel covers more than one pixel.\n\t\t\t *\n\t\t\t * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}\n\t\t\t * @default LinearFilter\n\t\t\t */\n\t\t\tthis.magFilter = magFilter;\n\n\t\t\t/**\n\t\t\t * How the texture is sampled when a texel covers less than one pixel.\n\t\t\t *\n\t\t\t * @type {(NearestFilter|NearestMipmapNearestFilter|NearestMipmapLinearFilter|LinearFilter|LinearMipmapNearestFilter|LinearMipmapLinearFilter)}\n\t\t\t * @default LinearMipmapLinearFilter\n\t\t\t */\n\t\t\tthis.minFilter = minFilter;\n\n\t\t\t/**\n\t\t\t * The number of samples taken along the axis through the pixel that has the\n\t\t\t * highest density of texels. By default, this value is `1`. A higher value\n\t\t\t * gives a less blurry result than a basic mipmap, at the cost of more\n\t\t\t * texture samples being used.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default 0\n\t\t\t */\n\t\t\tthis.anisotropy = anisotropy;\n\n\t\t\t/**\n\t\t\t * The format of the texture.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default RGBAFormat\n\t\t\t */\n\t\t\tthis.format = format;\n\n\t\t\t/**\n\t\t\t * The default internal format is derived from {@link Texture#format} and {@link Texture#type} and\n\t\t\t * defines how the texture data is going to be stored on the GPU.\n\t\t\t *\n\t\t\t * This property allows to overwrite the default format.\n\t\t\t *\n\t\t\t * @type {?string}\n\t\t\t * @default null\n\t\t\t */\n\t\t\tthis.internalFormat = null;\n\n\t\t\t/**\n\t\t\t * The data type of the texture.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default UnsignedByteType\n\t\t\t */\n\t\t\tthis.type = type;\n\n\t\t\t/**\n\t\t\t * How much a single repetition of the texture is offset from the beginning,\n\t\t\t * in each direction U and V. Typical range is `0.0` to `1.0`.\n\t\t\t *\n\t\t\t * @type {Vector2}\n\t\t\t * @default (0,0)\n\t\t\t */\n\t\t\tthis.offset = new Vector2( 0, 0 );\n\n\t\t\t/**\n\t\t\t * How many times the texture is repeated across the surface, in each\n\t\t\t * direction U and V. If repeat is set greater than `1` in either direction,\n\t\t\t * the corresponding wrap parameter should also be set to `RepeatWrapping`\n\t\t\t * or `MirroredRepeatWrapping` to achieve the desired tiling effect.\n\t\t\t *\n\t\t\t * @type {Vector2}\n\t\t\t * @default (1,1)\n\t\t\t */\n\t\t\tthis.repeat = new Vector2( 1, 1 );\n\n\t\t\t/**\n\t\t\t * The point around which rotation occurs. A value of `(0.5, 0.5)` corresponds\n\t\t\t * to the center of the texture. Default is `(0, 0)`, the lower left.\n\t\t\t *\n\t\t\t * @type {Vector2}\n\t\t\t * @default (0,0)\n\t\t\t */\n\t\t\tthis.center = new Vector2( 0, 0 );\n\n\t\t\t/**\n\t\t\t * How much the texture is rotated around the center point, in radians.\n\t\t\t * Positive values are counter-clockwise.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default 0\n\t\t\t */\n\t\t\tthis.rotation = 0;\n\n\t\t\t/**\n\t\t\t * Whether to update the texture's uv-transformation {@link Texture#matrix}\n\t\t\t * from the properties {@link Texture#offset}, {@link Texture#repeat},\n\t\t\t * {@link Texture#rotation}, and {@link Texture#center}.\n\t\t\t *\n\t\t\t * Set this to `false` if you are specifying the uv-transform matrix directly.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @default true\n\t\t\t */\n\t\t\tthis.matrixAutoUpdate = true;\n\n\t\t\t/**\n\t\t\t * The uv-transformation matrix of the texture.\n\t\t\t *\n\t\t\t * @type {Matrix3}\n\t\t\t */\n\t\t\tthis.matrix = new Matrix3();\n\n\t\t\t/**\n\t\t\t * Whether to generate mipmaps (if possible) for a texture.\n\t\t\t *\n\t\t\t * Set this to `false` if you are creating mipmaps manually.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @default true\n\t\t\t */\n\t\t\tthis.generateMipmaps = true;\n\n\t\t\t/**\n\t\t\t * If set to `true`, the alpha channel, if present, is multiplied into the\n\t\t\t * color channels when the texture is uploaded to the GPU.\n\t\t\t *\n\t\t\t * Note that this property has no effect when using `ImageBitmap`. You need to\n\t\t\t * configure premultiply alpha on bitmap creation instead.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @default false\n\t\t\t */\n\t\t\tthis.premultiplyAlpha = false;\n\n\t\t\t/**\n\t\t\t * If set to `true`, the texture is flipped along the vertical axis when\n\t\t\t * uploaded to the GPU.\n\t\t\t *\n\t\t\t * Note that this property has no effect when using `ImageBitmap`. You need to\n\t\t\t * configure the flip on bitmap creation instead.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @default true\n\t\t\t */\n\t\t\tthis.flipY = true;\n\n\t\t\t/**\n\t\t\t * Specifies the alignment requirements for the start of each pixel row in memory.\n\t\t\t * The allowable values are `1` (byte-alignment), `2` (rows aligned to even-numbered bytes),\n\t\t\t * `4` (word-alignment), and `8` (rows start on double-word boundaries).\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default 4\n\t\t\t */\n\t\t\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\t\t\t/**\n\t\t\t * Textures containing color data should be annotated with `SRGBColorSpace` or `LinearSRGBColorSpace`.\n\t\t\t *\n\t\t\t * @type {string}\n\t\t\t * @default NoColorSpace\n\t\t\t */\n\t\t\tthis.colorSpace = colorSpace;\n\n\t\t\t/**\n\t\t\t * An object that can be used to store custom data about the texture. It\n\t\t\t * should not hold references to functions as these will not be cloned.\n\t\t\t *\n\t\t\t * @type {Object}\n\t\t\t */\n\t\t\tthis.userData = {};\n\n\t\t\t/**\n\t\t\t * This can be used to only update a subregion or specific rows of the texture (for example, just the\n\t\t\t * first 3 rows). Use the `addUpdateRange()` function to add ranges to this array.\n\t\t\t *\n\t\t\t * @type {Array<Object>}\n\t\t\t */\n\t\t\tthis.updateRanges = [];\n\n\t\t\t/**\n\t\t\t * This starts at `0` and counts how many times {@link Texture#needsUpdate} is set to `true`.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @readonly\n\t\t\t * @default 0\n\t\t\t */\n\t\t\tthis.version = 0;\n\n\t\t\t/**\n\t\t\t * A callback function, called when the texture is updated (e.g., when\n\t\t\t * {@link Texture#needsUpdate} has been set to true and then the texture is used).\n\t\t\t *\n\t\t\t * @type {?Function}\n\t\t\t * @default null\n\t\t\t */\n\t\t\tthis.onUpdate = null;\n\n\t\t\t/**\n\t\t\t * An optional back reference to the textures render target.\n\t\t\t *\n\t\t\t * @type {?(RenderTarget|WebGLRenderTarget)}\n\t\t\t * @default null\n\t\t\t */\n\t\t\tthis.renderTarget = null;\n\n\t\t\t/**\n\t\t\t * Indicates whether a texture belongs to a render target or not.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @readonly\n\t\t\t * @default false\n\t\t\t */\n\t\t\tthis.isRenderTargetTexture = false;\n\n\t\t\t/**\n\t\t\t * Indicates if a texture should be handled like a texture array.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @readonly\n\t\t\t * @default false\n\t\t\t */\n\t\t\tthis.isArrayTexture = image && image.depth && image.depth > 1 ? true : false;\n\n\t\t\t/**\n\t\t\t * Indicates whether this texture should be processed by `PMREMGenerator` or not\n\t\t\t * (only relevant for render target textures).\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @readonly\n\t\t\t * @default 0\n\t\t\t */\n\t\t\tthis.pmremVersion = 0;\n\n\t\t}\n\n\t\t/**\n\t\t * The width of the texture in pixels.\n\t\t */\n\t\tget width() {\n\n\t\t\treturn this.source.getSize( _tempVec3 ).x;\n\n\t\t}\n\n\t\t/**\n\t\t * The height of the texture in pixels.\n\t\t */\n\t\tget height() {\n\n\t\t\treturn this.source.getSize( _tempVec3 ).y;\n\n\t\t}\n\n\t\t/**\n\t\t * The depth of the texture in pixels.\n\t\t */\n\t\tget depth() {\n\n\t\t\treturn this.source.getSize( _tempVec3 ).z;\n\n\t\t}\n\n\t\t/**\n\t\t * The image object holding the texture data.\n\t\t *\n\t\t * @type {?Object}\n\t\t */\n\t\tget image() {\n\n\t\t\treturn this.source.data;\n\n\t\t}\n\n\t\tset image( value = null ) {\n\n\t\t\tthis.source.data = value;\n\n\t\t}\n\n\t\t/**\n\t\t * Updates the texture transformation matrix from the from the properties {@link Texture#offset},\n\t\t * {@link Texture#repeat}, {@link Texture#rotation}, and {@link Texture#center}.\n\t\t */\n\t\tupdateMatrix() {\n\n\t\t\tthis.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );\n\n\t\t}\n\n\t\t/**\n\t\t * Adds a range of data in the data texture to be updated on the GPU.\n\t\t *\n\t\t * @param {number} start - Position at which to start update.\n\t\t * @param {number} count - The number of components to update.\n\t\t */\n\t\taddUpdateRange( start, count ) {\n\n\t\t\tthis.updateRanges.push( { start, count } );\n\n\t\t}\n\n\t\t/**\n\t\t * Clears the update ranges.\n\t\t */\n\t\tclearUpdateRanges() {\n\n\t\t\tthis.updateRanges.length = 0;\n\n\t\t}\n\n\t\t/**\n\t\t * Returns a new texture with copied values from this instance.\n\t\t *\n\t\t * @return {Texture} A clone of this instance.\n\t\t */\n\t\tclone() {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t}\n\n\t\t/**\n\t\t * Copies the values of the given texture to this instance.\n\t\t *\n\t\t * @param {Texture} source - The texture to copy.\n\t\t * @return {Texture} A reference to this instance.\n\t\t */\n\t\tcopy( source ) {\n\n\t\t\tthis.name = source.name;\n\n\t\t\tthis.source = source.source;\n\t\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\t\tthis.mapping = source.mapping;\n\t\t\tthis.channel = source.channel;\n\n\t\t\tthis.wrapS = source.wrapS;\n\t\t\tthis.wrapT = source.wrapT;\n\n\t\t\tthis.magFilter = source.magFilter;\n\t\t\tthis.minFilter = source.minFilter;\n\n\t\t\tthis.anisotropy = source.anisotropy;\n\n\t\t\tthis.format = source.format;\n\t\t\tthis.internalFormat = source.internalFormat;\n\t\t\tthis.type = source.type;\n\n\t\t\tthis.offset.copy( source.offset );\n\t\t\tthis.repeat.copy( source.repeat );\n\t\t\tthis.center.copy( source.center );\n\t\t\tthis.rotation = source.rotation;\n\n\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\t\tthis.matrix.copy( source.matrix );\n\n\t\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\t\tthis.flipY = source.flipY;\n\t\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\t\tthis.colorSpace = source.colorSpace;\n\n\t\t\tthis.renderTarget = source.renderTarget;\n\t\t\tthis.isRenderTargetTexture = source.isRenderTargetTexture;\n\t\t\tthis.isArrayTexture = source.isArrayTexture;\n\n\t\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets this texture's properties based on `values`.\n\t\t * @param {Object} values - A container with texture parameters.\n\t\t */\n\t\tsetValues( values ) {\n\n\t\t\tfor ( const key in values ) {\n\n\t\t\t\tconst newValue = values[ key ];\n\n\t\t\t\tif ( newValue === undefined ) {\n\n\t\t\t\t\tconsole.warn( `THREE.Texture.setValues(): parameter '${ key }' has value of undefined.` );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tconst currentValue = this[ key ];\n\n\t\t\t\tif ( currentValue === undefined ) {\n\n\t\t\t\t\tconsole.warn( `THREE.Texture.setValues(): property '${ key }' does not exist.` );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ( currentValue && newValue ) && ( currentValue.isVector2 && newValue.isVector2 ) ) {\n\n\t\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t\t} else if ( ( currentValue && newValue ) && ( currentValue.isVector3 && newValue.isVector3 ) ) {\n\n\t\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t\t} else if ( ( currentValue && newValue ) && ( currentValue.isMatrix3 && newValue.isMatrix3 ) ) {\n\n\t\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis[ key ] = newValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * Serializes the texture into JSON.\n\t\t *\n\t\t * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.\n\t\t * @return {Object} A JSON object representing the serialized texture.\n\t\t * @see {@link ObjectLoader#parse}\n\t\t */\n\t\ttoJSON( meta ) {\n\n\t\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\t\tif ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t\t}\n\n\t\t\tconst output = {\n\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.7,\n\t\t\t\t\ttype: 'Texture',\n\t\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t\t},\n\n\t\t\t\tuuid: this.uuid,\n\t\t\t\tname: this.name,\n\n\t\t\t\timage: this.source.toJSON( meta ).uuid,\n\n\t\t\t\tmapping: this.mapping,\n\t\t\t\tchannel: this.channel,\n\n\t\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\t\tcenter: [ this.center.x, this.center.y ],\n\t\t\t\trotation: this.rotation,\n\n\t\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\t\tformat: this.format,\n\t\t\t\tinternalFormat: this.internalFormat,\n\t\t\t\ttype: this.type,\n\t\t\t\tcolorSpace: this.colorSpace,\n\n\t\t\t\tminFilter: this.minFilter,\n\t\t\t\tmagFilter: this.magFilter,\n\t\t\t\tanisotropy: this.anisotropy,\n\n\t\t\t\tflipY: this.flipY,\n\n\t\t\t\tgenerateMipmaps: this.generateMipmaps,\n\t\t\t\tpremultiplyAlpha: this.premultiplyAlpha,\n\t\t\t\tunpackAlignment: this.unpackAlignment\n\n\t\t\t};\n\n\t\t\tif ( Object.keys( this.userData ).length > 0 ) output.userData = this.userData;\n\n\t\t\tif ( ! isRootObject ) {\n\n\t\t\t\tmeta.textures[ this.uuid ] = output;\n\n\t\t\t}\n\n\t\t\treturn output;\n\n\t\t}\n\n\t\t/**\n\t\t * Frees the GPU-related resources allocated by this instance. Call this\n\t\t * method whenever this instance is no longer used in your app.\n\t\t *\n\t\t * @fires Texture#dispose\n\t\t */\n\t\tdispose() {\n\n\t\t\t/**\n\t\t\t * Fires when the texture has been disposed of.\n\t\t\t *\n\t\t\t * @event Texture#dispose\n\t\t\t * @type {Object}\n\t\t\t */\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\t}\n\n\t\t/**\n\t\t * Transforms the given uv vector with the textures uv transformation matrix.\n\t\t *\n\t\t * @param {Vector2} uv - The uv vector.\n\t\t * @return {Vector2} The transformed uv vector.\n\t\t */\n\t\ttransformUv( uv ) {\n\n\t\t\tif ( this.mapping !== UVMapping ) return uv;\n\n\t\t\tuv.applyMatrix3( this.matrix );\n\n\t\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.flipY ) {\n\n\t\t\t\tuv.y = 1 - uv.y;\n\n\t\t\t}\n\n\t\t\treturn uv;\n\n\t\t}\n\n\t\t/**\n\t\t * Setting this property to `true` indicates the engine the texture\n\t\t * must be updated in the next render. This triggers a texture upload\n\t\t * to the GPU and ensures correct texture parameter configuration.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t * @param {boolean} value\n\t\t */\n\t\tset needsUpdate( value ) {\n\n\t\t\tif ( value === true ) {\n\n\t\t\t\tthis.version ++;\n\t\t\t\tthis.source.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * Setting this property to `true` indicates the engine the PMREM\n\t\t * must be regenerated.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t * @param {boolean} value\n\t\t */\n\t\tset needsPMREMUpdate( value ) {\n\n\t\t\tif ( value === true ) {\n\n\t\t\t\tthis.pmremVersion ++;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The default image for all textures.\n\t *\n\t * @static\n\t * @type {?Image}\n\t * @default null\n\t */\n\tTexture.DEFAULT_IMAGE = null;\n\n\t/**\n\t * The default mapping for all textures.\n\t *\n\t * @static\n\t * @type {number}\n\t * @default UVMapping\n\t */\n\tTexture.DEFAULT_MAPPING = UVMapping;\n\n\t/**\n\t * The default anisotropy value for all textures.\n\t *\n\t * @static\n\t * @type {number}\n\t * @default 1\n\t */\n\tTexture.DEFAULT_ANISOTROPY = 1;\n\n\tconst _vector$a = /*@__PURE__*/ new Vector3();\n\tconst _segCenter = /*@__PURE__*/ new Vector3();\n\tconst _segDir = /*@__PURE__*/ new Vector3();\n\tconst _diff = /*@__PURE__*/ new Vector3();\n\n\tconst _edge1 = /*@__PURE__*/ new Vector3();\n\tconst _edge2 = /*@__PURE__*/ new Vector3();\n\tconst _normal$1 = /*@__PURE__*/ new Vector3();\n\n\t/**\n\t * A ray that emits from an origin in a certain direction. The class is used by\n\t * {@link Raycaster} to assist with raycasting. Raycasting is used for\n\t * mouse picking (working out what objects in the 3D space the mouse is over)\n\t * amongst other things.\n\t */\n\tclass Ray {\n\n\t\t/**\n\t\t * Constructs a new ray.\n\t\t *\n\t\t * @param {Vector3} [origin=(0,0,0)] - The origin of the ray.\n\t\t * @param {Vector3} [direction=(0,0,-1)] - The (normalized) direction of the ray.\n\t\t */\n\t\tconstructor( origin = new Vector3(), direction = new Vector3( 0, 0, -1 ) ) {\n\n\t\t\t/**\n\t\t\t * The origin of the ray.\n\t\t\t *\n\t\t\t * @type {Vector3}\n\t\t\t */\n\t\t\tthis.origin = origin;\n\n\t\t\t/**\n\t\t\t * The (normalized) direction of the ray.\n\t\t\t *\n\t\t\t * @type {Vector3}\n\t\t\t */\n\t\t\tthis.direction = direction;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the ray's components by copying the given values.\n\t\t *\n\t\t * @param {Vector3} origin - The origin.\n\t\t * @param {Vector3} direction - The direction.\n\t\t * @return {Ray} A reference to this ray.\n\t\t */\n\t\tset( origin, direction ) {\n\n\t\t\tthis.origin.copy( origin );\n\t\t\tthis.direction.copy( direction );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Copies the values of the given ray to this instance.\n\t\t *\n\t\t * @param {Ray} ray - The ray to copy.\n\t\t * @return {Ray} A reference to this ray.\n\t\t */\n\t\tcopy( ray ) {\n\n\t\t\tthis.origin.copy( ray.origin );\n\t\t\tthis.direction.copy( ray.direction );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Returns a vector that is located at a given distance along this ray.\n\t\t *\n\t\t * @param {number} t - The distance along the ray to retrieve a position for.\n\t\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t\t * @return {Vector3} A position on the ray.\n\t\t */\n\t\tat( t, target ) {\n\n\t\t\treturn target.copy( this.origin ).addScaledVector( this.direction, t );\n\n\t\t}\n\n\t\t/**\n\t\t * Adjusts the direction of the ray to point at the given vector in world space.\n\t\t *\n\t\t * @param {Vector3} v - The target position.\n\t\t * @return {Ray} A reference to this ray.\n\t\t */\n\t\tlookAt( v ) {\n\n\t\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Shift the origin of this ray along its direction by the given distance.\n\t\t *\n\t\t * @param {number} t - The distance along the ray to interpolate.\n\t\t * @return {Ray} A reference to this ray.\n\t\t */\n\t\trecast( t ) {\n\n\t\t\tthis.origin.copy( this.at( t, _vector$a ) );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Returns the point along this ray that is closest to the given point.\n\t\t *\n\t\t * @param {Vector3} point - A point in 3D space to get the closet location on the ray for.\n\t\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t\t * @return {Vector3} The closest point on this ray.\n\t\t */\n\t\tclosestPointToPoint( point, target ) {\n\n\t\t\ttarget.subVectors( point, this.origin );\n\n\t\t\tconst directionDistance = target.dot( this.direction );\n\n\t\t\tif ( directionDistance < 0 ) {\n\n\t\t\t\treturn target.copy( this.origin );\n\n\t\t\t}\n\n\t\t\treturn target.copy( this.origin ).addScaledVector( this.direction, directionDistance );\n\n\t\t}\n\n\t\t/**\n\t\t * Returns the distance of the closest approach between this ray and the given point.\n\t\t *\n\t\t * @param {Vector3} point - A point in 3D space to compute the distance to.\n\t\t * @return {number} The distance.\n\t\t */\n\t\tdistanceToPoint( point ) {\n\n\t\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t\t}\n\n\t\t/**\n\t\t * Returns the squared distance of the closest approach between this ray and the given point.\n\t\t *\n\t\t * @param {Vector3} point - A point in 3D space to compute the distance to.\n\t\t * @return {number} The squared distance.\n\t\t */\n\t\tdistanceSqToPoint( point ) {\n\n\t\t\tconst directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t\t// point behind the ray\n\n\t\t\tif ( directionDistance < 0 ) {\n\n\t\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t\t}\n\n\t\t\t_vector$a.copy( this.origin ).addScaledVector( this.direction, directionDistance );\n\n\t\t\treturn _vector$a.distanceToSquared( point );\n\n\t\t}\n\n\t\t/**\n\t\t * Returns the squared distance between this ray and the given line segment.\n\t\t *\n\t\t * @param {Vector3} v0 - The start point of the line segment.\n\t\t * @param {Vector3} v1 - The end point of the line segment.\n\t\t * @param {Vector3} [optionalPointOnRay] - When provided, it receives the point on this ray that is closest to the segment.\n\t\t * @param {Vector3} [optionalPointOnSegment] - When provided, it receives the point on the line segment that is closest to this ray.\n\t\t * @return {number} The squared distance.\n\t\t */\n\t\tdistanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t\t// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t\t// It returns the min distance between the ray and the segment\n\t\t\t// defined by v0 and v1\n\t\t\t// It can also set two optional targets :\n\t\t\t// - The closest point on the ray\n\t\t\t// - The closest point on the segment\n\n\t\t\t_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t\t_segDir.copy( v1 ).sub( v0 ).normalize();\n\t\t\t_diff.copy( this.origin ).sub( _segCenter );\n\n\t\t\tconst segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\t\tconst a01 = - this.direction.dot( _segDir );\n\t\t\tconst b0 = _diff.dot( this.direction );\n\t\t\tconst b1 = - _diff.dot( _segDir );\n\t\t\tconst c = _diff.lengthSq();\n\t\t\tconst det = Math.abs( 1 - a01 * a01 );\n\t\t\tlet s0, s1, sqrDist, extDet;\n\n\t\t\tif ( det > 0 ) {\n\n\t\t\t\t// The ray and segment are not parallel.\n\n\t\t\t\ts0 = a01 * b1 - b0;\n\t\t\t\ts1 = a01 * b0 - b1;\n\t\t\t\textDet = segExtent * det;\n\n\t\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\t\tconst invDet = 1 / det;\n\t\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 5\n\n\t\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t\t// region 4\n\n\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t\t// region 3\n\n\t\t\t\t\t\ts0 = 0;\n\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 2\n\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Ray and segment are parallel.\n\n\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t}\n\n\t\t\tif ( optionalPointOnRay ) {\n\n\t\t\t\toptionalPointOnRay.copy( this.origin ).addScaledVector( this.direction, s0 );\n\n\t\t\t}\n\n\t\t\tif ( optionalPointOnSegment ) {\n\n\t\t\t\toptionalPointOnSegment.copy( _segCenter ).addScaledVector( _segDir, s1 );\n\n\t\t\t}\n\n\t\t\treturn sqrDist;\n\n\t\t}\n\n\t\t/**\n\t\t * Intersects this ray with the given sphere, returning the intersection\n\t\t * point or `null` if there is no intersection.\n\t\t *\n\t\t * @param {Sphere} sphere - The sphere to intersect.\n\t\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t\t * @return {?Vector3} The intersection point.\n\t\t */\n\t\tintersectSphere( sphere, target ) {\n\n\t\t\t_vector$a.subVectors( sphere.center, this.origin );\n\t\t\tconst tca = _vector$a.dot( this.direction );\n\t\t\tconst d2 = _vector$a.dot( _vector$a ) - tca * tca;\n\t\t\tconst radius2 = sphere.radius * sphere.radius;\n\n\t\t\tif ( d2 > radius2 ) return null;\n\n\t\t\tconst thc = Math.sqrt( radius2 - d2 );\n\n\t\t\t// t0 = first intersect point - entrance on front of sphere\n\t\t\tconst t0 = tca - thc;\n\n\t\t\t// t1 = second intersect point - exit point on back of sphere\n\t\t\tconst t1 = tca + thc;\n\n\t\t\t// test to see if t1 is behind the ray - if so, return null\n\t\t\tif ( t1 < 0 ) return null;\n\n\t\t\t// test to see if t0 is behind the ray:\n\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t\t// in order to always return an intersect point that is in front of the ray.\n\t\t\tif ( t0 < 0 ) return this.at( t1, target );\n\n\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\t\treturn this.at( t0, target );\n\n\t\t}\n\n\t\t/**\n\t\t * Returns `true` if this ray intersects with the given sphere.\n\t\t *\n\t\t * @param {Sphere} sphere - The sphere to intersect.\n\t\t * @return {boolean} Whether this ray intersects with the given sphere or not.\n\t\t */\n\t\tintersectsSphere( sphere ) {\n\n\t\t\tif ( sphere.radius < 0 ) return false; // handle empty spheres, see #31187\n\n\t\t\treturn this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t\t}\n\n\t\t/**\n\t\t * Computes the distance from the ray's origin to the given plane. Returns `null` if the ray\n\t\t * does not intersect with the plane.\n\t\t *\n\t\t * @param {Plane} plane - The plane to compute the distance to.\n\t\t * @return {?number} Whether this ray intersects with the given sphere or not.\n\t\t */\n\t\tdistanceToPlane( plane ) {\n\n\t\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\t\tif ( denominator === 0 ) {\n\n\t\t\t\t// line is coplanar, return origin\n\t\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\t\treturn 0;\n\n\t\t\t\t}\n\n\t\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tconst t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t\t// Return if the ray never intersects the plane\n\n\t\t\treturn t >= 0 ? t : null;\n\n\t\t}\n\n\t\t/**\n\t\t * Intersects this ray with the given plane, returning the intersection\n\t\t * point or `null` if there is no intersection.\n\t\t *\n\t\t * @param {Plane} plane - The plane to intersect.\n\t\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t\t * @return {?Vector3} The intersection point.\n\t\t */\n\t\tintersectPlane( plane, target ) {\n\n\t\t\tconst t = this.distanceToPlane( plane );\n\n\t\t\tif ( t === null ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\treturn this.at( t, target );\n\n\t\t}\n\n\t\t/**\n\t\t * Returns `true` if this ray intersects with the given plane.\n\t\t *\n\t\t * @param {Plane} plane - The plane to intersect.\n\t\t * @return {boolean} Whether this ray intersects with the given plane or not.\n\t\t */\n\t\tintersectsPlane( plane ) {\n\n\t\t\t// check if the ray lies on the plane first\n\n\t\t\tconst distToPoint = plane.distanceToPoint( this.origin );\n\n\t\t\tif ( distToPoint === 0 ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t/**\n\t\t * Intersects this ray with the given bounding box, returning the intersection\n\t\t * point or `null` if there is no intersection.\n\t\t *\n\t\t * @param {Box3} box - The box to intersect.\n\t\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t\t * @return {?Vector3} The intersection point.\n\t\t */\n\t\tintersectBox( box, target ) {\n\n\t\t\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\t\tconst invdirx = 1 / this.direction.x,\n\t\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\t\tconst origin = this.origin;\n\n\t\t\tif ( invdirx >= 0 ) {\n\n\t\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t\t} else {\n\n\t\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t\t}\n\n\t\t\tif ( invdiry >= 0 ) {\n\n\t\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t\t} else {\n\n\t\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t\t}\n\n\t\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\t\tif ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;\n\n\t\t\tif ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;\n\n\t\t\tif ( invdirz >= 0 ) {\n\n\t\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t\t} else {\n\n\t\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t\t}\n\n\t\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t\t//return point closest to the ray (positive side)\n\n\t\t\tif ( tmax < 0 ) return null;\n\n\t\t\treturn this.at( tmin >= 0 ? tmin : tmax, target );\n\n\t\t}\n\n\t\t/**\n\t\t * Returns `true` if this ray intersects with the given box.\n\t\t *\n\t\t * @param {Box3} box - The box to intersect.\n\t\t * @return {boolean} Whether this ray intersects with the given box or not.\n\t\t */\n\t\tintersectsBox( box ) {\n\n\t\t\treturn this.intersectBox( box, _vector$a ) !== null;\n\n\t\t}\n\n\t\t/**\n\t\t * Intersects this ray with the given triangle, returning the intersection\n\t\t * point or `null` if there is no intersection.\n\t\t *\n\t\t * @param {Vector3} a - The first vertex of the triangle.\n\t\t * @param {Vector3} b - The second vertex of the triangle.\n\t\t * @param {Vector3} c - The third vertex of the triangle.\n\t\t * @param {boolean} backfaceCulling - Whether to use backface culling or not.\n\t\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t\t * @return {?Vector3} The intersection point.\n\t\t */\n\t\tintersectTriangle( a, b, c, backfaceCulling, target ) {\n\n\t\t\t// Compute the offset origin, edges, and normal.\n\n\t\t\t// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t\t_edge1.subVectors( b, a );\n\t\t\t_edge2.subVectors( c, a );\n\t\t\t_normal$1.crossVectors( _edge1, _edge2 );\n\n\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\t\tlet DdN = this.direction.dot( _normal$1 );\n\t\t\tlet sign;\n\n\t\t\tif ( DdN > 0 ) {\n\n\t\t\t\tif ( backfaceCulling ) return null;\n\t\t\t\tsign = 1;\n\n\t\t\t} else if ( DdN < 0 ) {\n\n\t\t\t\tsign = -1;\n\t\t\t\tDdN = - DdN;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t_diff.subVectors( this.origin, a );\n\t\t\tconst DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );\n\n\t\t\t// b1 < 0, no intersection\n\t\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tconst DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );\n\n\t\t\t// b2 < 0, no intersection\n\t\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// b1+b2 > 1, no intersection\n\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// Line intersects triangle, check if ray does.\n\t\t\tconst QdN = - sign * _diff.dot( _normal$1 );\n\n\t\t\t// t < 0, no intersection\n\t\t\tif ( QdN < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// Ray intersects triangle.\n\t\t\treturn this.at( QdN / DdN, target );\n\n\t\t}\n\n\t\t/**\n\t\t * Transforms this ray with the given 4x4 transformation matrix.\n\t\t *\n\t\t * @param {Matrix4} matrix4 - The transformation matrix.\n\t\t * @return {Ray} A reference to this ray.\n\t\t */\n\t\tapplyMatrix4( matrix4 ) {\n\n\t\t\tthis.origin.applyMatrix4( matrix4 );\n\t\t\tthis.direction.transformDirection( matrix4 );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Returns `true` if this ray is equal with the given one.\n\t\t *\n\t\t * @param {Ray} ray - The ray to test for equality.\n\t\t * @return {boolean} Whether this ray is equal with the given one.\n\t\t */\n\t\tequals( ray ) {\n\n\t\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t\t}\n\n\t\t/**\n\t\t * Returns a new ray with copied values from this instance.\n\t\t *\n\t\t * @return {Ray} A clone of this instance.\n\t\t */\n\t\tclone() {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Represents a 4x4 matrix.\n\t *\n\t * The most common use of a 4x4 matrix in 3D computer graphics is as a transformation matrix.\n\t * For an introduction to transformation matrices as used in WebGL, check out [this tutorial]{@link https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices}\n\t *\n\t * This allows a 3D vector representing a point in 3D space to undergo\n\t * transformations such as translation, rotation, shear, scale, reflection,\n\t * orthogonal or perspective projection and so on, by being multiplied by the\n\t * matrix. This is known as `applying` the matrix to the vector.\n\t *\n\t * A Note on Row-Major and Column-Major Ordering:\n\t *\n\t * The constructor and {@link Matrix3#set} method take arguments in\n\t * [row-major]{@link https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order}\n\t * order, while internally they are stored in the {@link Matrix3#elements} array in column-major order.\n\t * This means that calling:\n\t * ```js\n\t * const m = new THREE.Matrix4();\n\t * m.set( 11, 12, 13, 14,\n\t *        21, 22, 23, 24,\n\t *        31, 32, 33, 34,\n\t *        41, 42, 43, 44 );\n\t * ```\n\t * will result in the elements array containing:\n\t * ```js\n\t * m.elements = [ 11, 21, 31, 41,\n\t *                12, 22, 32, 42,\n\t *                13, 23, 33, 43,\n\t *                14, 24, 34, 44 ];\n\t * ```\n\t * and internally all calculations are performed using column-major ordering.\n\t * However, as the actual ordering makes no difference mathematically and\n\t * most people are used to thinking about matrices in row-major order, the\n\t * three.js documentation shows matrices in row-major order. Just bear in\n\t * mind that if you are reading the source code, you'll have to take the\n\t * transpose of any matrices outlined here to make sense of the calculations.\n\t */\n\tclass Matrix4 {\n\n\t\t/**\n\t\t * Constructs a new 4x4 matrix. The arguments are supposed to be\n\t\t * in row-major order. If no arguments are provided, the constructor\n\t\t * initializes the matrix as an identity matrix.\n\t\t *\n\t\t * @param {number} [n11] - 1-1 matrix element.\n\t\t * @param {number} [n12] - 1-2 matrix element.\n\t\t * @param {number} [n13] - 1-3 matrix element.\n\t\t * @param {number} [n14] - 1-4 matrix element.\n\t\t * @param {number} [n21] - 2-1 matrix element.\n\t\t * @param {number} [n22] - 2-2 matrix element.\n\t\t * @param {number} [n23] - 2-3 matrix element.\n\t\t * @param {number} [n24] - 2-4 matrix element.\n\t\t * @param {number} [n31] - 3-1 matrix element.\n\t\t * @param {number} [n32] - 3-2 matrix element.\n\t\t * @param {number} [n33] - 3-3 matrix element.\n\t\t * @param {number} [n34] - 3-4 matrix element.\n\t\t * @param {number} [n41] - 4-1 matrix element.\n\t\t * @param {number} [n42] - 4-2 matrix element.\n\t\t * @param {number} [n43] - 4-3 matrix element.\n\t\t * @param {number} [n44] - 4-4 matrix element.\n\t\t */\n\t\tconstructor( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\t\t/**\n\t\t\t * This flag can be used for type testing.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @readonly\n\t\t\t * @default true\n\t\t\t */\n\t\t\tMatrix4.prototype.isMatrix4 = true;\n\n\t\t\t/**\n\t\t\t * A column-major list of matrix values.\n\t\t\t *\n\t\t\t * @type {Array<number>}\n\t\t\t */\n\t\t\tthis.elements = [\n\n\t\t\t\t1, 0, 0, 0,\n\t\t\t\t0, 1, 0, 0,\n\t\t\t\t0, 0, 1, 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t];\n\n\t\t\tif ( n11 !== undefined ) {\n\n\t\t\t\tthis.set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the elements of the matrix.The arguments are supposed to be\n\t\t * in row-major order.\n\t\t *\n\t\t * @param {number} [n11] - 1-1 matrix element.\n\t\t * @param {number} [n12] - 1-2 matrix element.\n\t\t * @param {number} [n13] - 1-3 matrix element.\n\t\t * @param {number} [n14] - 1-4 matrix element.\n\t\t * @param {number} [n21] - 2-1 matrix element.\n\t\t * @param {number} [n22] - 2-2 matrix element.\n\t\t * @param {number} [n23] - 2-3 matrix element.\n\t\t * @param {number} [n24] - 2-4 matrix element.\n\t\t * @param {number} [n31] - 3-1 matrix element.\n\t\t * @param {number} [n32] - 3-2 matrix element.\n\t\t * @param {number} [n33] - 3-3 matrix element.\n\t\t * @param {number} [n34] - 3-4 matrix element.\n\t\t * @param {number} [n41] - 4-1 matrix element.\n\t\t * @param {number} [n42] - 4-2 matrix element.\n\t\t * @param {number} [n43] - 4-3 matrix element.\n\t\t * @param {number} [n44] - 4-4 matrix element.\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\tset( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\t\tconst te = this.elements;\n\n\t\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets this matrix to the 4x4 identity matrix.\n\t\t *\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\tidentity() {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, 0,\n\t\t\t\t0, 1, 0, 0,\n\t\t\t\t0, 0, 1, 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Returns a matrix with copied values from this instance.\n\t\t *\n\t\t * @return {Matrix4} A clone of this instance.\n\t\t */\n\t\tclone() {\n\n\t\t\treturn new Matrix4().fromArray( this.elements );\n\n\t\t}\n\n\t\t/**\n\t\t * Copies the values of the given matrix to this instance.\n\t\t *\n\t\t * @param {Matrix4} m - The matrix to copy.\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\tcopy( m ) {\n\n\t\t\tconst te = this.elements;\n\t\t\tconst me = m.elements;\n\n\t\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];\n\t\t\tte[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];\n\t\t\tte[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];\n\t\t\tte[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Copies the translation component of the given matrix\n\t\t * into this matrix's translation component.\n\t\t *\n\t\t * @param {Matrix4} m - The matrix to copy the translation component.\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\tcopyPosition( m ) {\n\n\t\t\tconst te = this.elements, me = m.elements;\n\n\t\t\tte[ 12 ] = me[ 12 ];\n\t\t\tte[ 13 ] = me[ 13 ];\n\t\t\tte[ 14 ] = me[ 14 ];\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Set the upper 3x3 elements of this matrix to the values of given 3x3 matrix.\n\t\t *\n\t\t * @param {Matrix3} m - The 3x3 matrix.\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\tsetFromMatrix3( m ) {\n\n\t\t\tconst me = m.elements;\n\n\t\t\tthis.set(\n\n\t\t\t\tme[ 0 ], me[ 3 ], me[ 6 ], 0,\n\t\t\t\tme[ 1 ], me[ 4 ], me[ 7 ], 0,\n\t\t\t\tme[ 2 ], me[ 5 ], me[ 8 ], 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Extracts the basis of this matrix into the three axis vectors provided.\n\t\t *\n\t\t * @param {Vector3} xAxis - The basis's x axis.\n\t\t * @param {Vector3} yAxis - The basis's y axis.\n\t\t * @param {Vector3} zAxis - The basis's z axis.\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\textractBasis( xAxis, yAxis, zAxis ) {\n\n\t\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\t\tzAxis.setFromMatrixColumn( this, 2 );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the given basis vectors to this matrix.\n\t\t *\n\t\t * @param {Vector3} xAxis - The basis's x axis.\n\t\t * @param {Vector3} yAxis - The basis's y axis.\n\t\t * @param {Vector3} zAxis - The basis's z axis.\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\tmakeBasis( xAxis, yAxis, zAxis ) {\n\n\t\t\tthis.set(\n\t\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t\t0, 0, 0, 1\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Extracts the rotation component of the given matrix\n\t\t * into this matrix's rotation component.\n\t\t *\n\t\t * Note: This method does not support reflection matrices.\n\t\t *\n\t\t * @param {Matrix4} m - The matrix.\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\textractRotation( m ) {\n\n\t\t\tconst te = this.elements;\n\t\t\tconst me = m.elements;\n\n\t\t\tconst scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();\n\t\t\tconst scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();\n\t\t\tconst scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();\n\n\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\t\t\tte[ 3 ] = 0;\n\n\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\t\t\tte[ 7 ] = 0;\n\n\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\t\t\tte[ 11 ] = 0;\n\n\t\t\tte[ 12 ] = 0;\n\t\t\tte[ 13 ] = 0;\n\t\t\tte[ 14 ] = 0;\n\t\t\tte[ 15 ] = 1;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the rotation component (the upper left 3x3 matrix) of this matrix to\n\t\t * the rotation specified by the given Euler angles. The rest of\n\t\t * the matrix is set to the identity. Depending on the {@link Euler#order},\n\t\t * there are six possible outcomes. See [this page]{@link https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix}\n\t\t * for a complete list.\n\t\t *\n\t\t * @param {Euler} euler - The Euler angles.\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\tmakeRotationFromEuler( euler ) {\n\n\t\t\tconst te = this.elements;\n\n\t\t\tconst x = euler.x, y = euler.y, z = euler.z;\n\t\t\tconst a = Math.cos( x ), b = Math.sin( x );\n\t\t\tconst c = Math.cos( y ), d = Math.sin( y );\n\t\t\tconst e = Math.cos( z ), f = Math.sin( z );\n\n\t\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\t\tconst ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = - c * f;\n\t\t\t\tte[ 8 ] = d;\n\n\t\t\t\tte[ 1 ] = af + be * d;\n\t\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\t\tte[ 9 ] = - b * c;\n\n\t\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\t\tte[ 6 ] = be + af * d;\n\t\t\t\tte[ 10 ] = a * c;\n\n\t\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\t\tconst ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\t\tte[ 0 ] = ce + df * b;\n\t\t\t\tte[ 4 ] = de * b - cf;\n\t\t\t\tte[ 8 ] = a * d;\n\n\t\t\t\tte[ 1 ] = a * f;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = - b;\n\n\t\t\t\tte[ 2 ] = cf * b - de;\n\t\t\t\tte[ 6 ] = df + ce * b;\n\t\t\t\tte[ 10 ] = a * c;\n\n\t\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\t\tconst ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\t\tte[ 0 ] = ce - df * b;\n\t\t\t\tte[ 4 ] = - a * f;\n\t\t\t\tte[ 8 ] = de + cf * b;\n\n\t\t\t\tte[ 1 ] = cf + de * b;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = df - ce * b;\n\n\t\t\t\tte[ 2 ] = - a * d;\n\t\t\t\tte[ 6 ] = b;\n\t\t\t\tte[ 10 ] = a * c;\n\n\t\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\t\tconst ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = be * d - af;\n\t\t\t\tte[ 8 ] = ae * d + bf;\n\n\t\t\t\tte[ 1 ] = c * f;\n\t\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\t\tte[ 9 ] = af * d - be;\n\n\t\t\t\tte[ 2 ] = - d;\n\t\t\t\tte[ 6 ] = b * c;\n\t\t\t\tte[ 10 ] = a * c;\n\n\t\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\t\tconst ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\t\tte[ 8 ] = bc * f + ad;\n\n\t\t\t\tte[ 1 ] = f;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = - b * e;\n\n\t\t\t\tte[ 2 ] = - d * e;\n\t\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\t\tte[ 10 ] = ac - bd * f;\n\n\t\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\t\tconst ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = - f;\n\t\t\t\tte[ 8 ] = d * e;\n\n\t\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = ad * f - bc;\n\n\t\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\t\tte[ 6 ] = b * e;\n\t\t\t\tte[ 10 ] = bd * f + ac;\n\n\t\t\t}\n\n\t\t\t// bottom row\n\t\t\tte[ 3 ] = 0;\n\t\t\tte[ 7 ] = 0;\n\t\t\tte[ 11 ] = 0;\n\n\t\t\t// last column\n\t\t\tte[ 12 ] = 0;\n\t\t\tte[ 13 ] = 0;\n\t\t\tte[ 14 ] = 0;\n\t\t\tte[ 15 ] = 1;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the rotation component of this matrix to the rotation specified by\n\t\t * the given Quaternion as outlined [here]{@link https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion}\n\t\t * The rest of the matrix is set to the identity.\n\t\t *\n\t\t * @param {Quaternion} q - The Quaternion.\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\tmakeRotationFromQuaternion( q ) {\n\n\t\t\treturn this.compose( _zero, q, _one );\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the rotation component of the transformation matrix, looking from `eye` towards\n\t\t * `target`, and oriented by the up-direction.\n\t\t *\n\t\t * @param {Vector3} eye - The eye vector.\n\t\t * @param {Vector3} target - The target vector.\n\t\t * @param {Vector3} up - The up vector.\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\tlookAt( eye, target, up ) {\n\n\t\t\tconst te = this.elements;\n\n\t\t\t_z.subVectors( eye, target );\n\n\t\t\tif ( _z.lengthSq() === 0 ) {\n\n\t\t\t\t// eye and target are in the same position\n\n\t\t\t\t_z.z = 1;\n\n\t\t\t}\n\n\t\t\t_z.normalize();\n\t\t\t_x.crossVectors( up, _z );\n\n\t\t\tif ( _x.lengthSq() === 0 ) {\n\n\t\t\t\t// up and z are parallel\n\n\t\t\t\tif ( Math.abs( up.z ) === 1 ) {\n\n\t\t\t\t\t_z.x += 0.0001;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_z.z += 0.0001;\n\n\t\t\t\t}\n\n\t\t\t\t_z.normalize();\n\t\t\t\t_x.crossVectors( up, _z );\n\n\t\t\t}\n\n\t\t\t_x.normalize();\n\t\t\t_y.crossVectors( _z, _x );\n\n\t\t\tte[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;\n\t\t\tte[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;\n\t\t\tte[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Post-multiplies this matrix by the given 4x4 matrix.\n\t\t *\n\t\t * @param {Matrix4} m - The matrix to multiply with.\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\tmultiply( m ) {\n\n\t\t\treturn this.multiplyMatrices( this, m );\n\n\t\t}\n\n\t\t/**\n\t\t * Pre-multiplies this matrix by the given 4x4 matrix.\n\t\t *\n\t\t * @param {Matrix4} m - The matrix to multiply with.\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\tpremultiply( m ) {\n\n\t\t\treturn this.multiplyMatrices( m, this );\n\n\t\t}\n\n\t\t/**\n\t\t * Multiples the given 4x4 matrices and stores the result\n\t\t * in this matrix.\n\t\t *\n\t\t * @param {Matrix4} a - The first matrix.\n\t\t * @param {Matrix4} b - The second matrix.\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\tmultiplyMatrices( a, b ) {\n\n\t\t\tconst ae = a.elements;\n\t\t\tconst be = b.elements;\n\t\t\tconst te = this.elements;\n\n\t\t\tconst a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\t\tconst a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\t\tconst a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\t\tconst a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\n\t\t\tconst b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\t\tconst b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\t\tconst b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\t\tconst b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\n\t\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Multiplies every component of the matrix by the given scalar.\n\t\t *\n\t\t * @param {number} s - The scalar.\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\tmultiplyScalar( s ) {\n\n\t\t\tconst te = this.elements;\n\n\t\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Computes and returns the determinant of this matrix.\n\t\t *\n\t\t * Based on the method outlined [here]{@link http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.html}.\n\t\t *\n\t\t * @return {number} The determinant.\n\t\t */\n\t\tdeterminant() {\n\n\t\t\tconst te = this.elements;\n\n\t\t\tconst n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\t\tconst n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\t\tconst n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\t\tconst n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\n\t\t\t//TODO: make this more efficient\n\n\t\t\treturn (\n\t\t\t\tn41 * (\n\t\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t\t - n13 * n24 * n32\n\t\t\t\t\t - n14 * n22 * n33\n\t\t\t\t\t + n12 * n24 * n33\n\t\t\t\t\t + n13 * n22 * n34\n\t\t\t\t\t - n12 * n23 * n34\n\t\t\t\t) +\n\t\t\t\tn42 * (\n\t\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t\t - n11 * n24 * n33\n\t\t\t\t\t + n14 * n21 * n33\n\t\t\t\t\t - n13 * n21 * n34\n\t\t\t\t\t + n13 * n24 * n31\n\t\t\t\t\t - n14 * n23 * n31\n\t\t\t\t) +\n\t\t\t\tn43 * (\n\t\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t\t - n11 * n22 * n34\n\t\t\t\t\t - n14 * n21 * n32\n\t\t\t\t\t + n12 * n21 * n34\n\t\t\t\t\t + n14 * n22 * n31\n\t\t\t\t\t - n12 * n24 * n31\n\t\t\t\t) +\n\t\t\t\tn44 * (\n\t\t\t\t\t- n13 * n22 * n31\n\t\t\t\t\t - n11 * n23 * n32\n\t\t\t\t\t + n11 * n22 * n33\n\t\t\t\t\t + n13 * n21 * n32\n\t\t\t\t\t - n12 * n21 * n33\n\t\t\t\t\t + n12 * n23 * n31\n\t\t\t\t)\n\n\t\t\t);\n\n\t\t}\n\n\t\t/**\n\t\t * Transposes this matrix in place.\n\t\t *\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\ttranspose() {\n\n\t\t\tconst te = this.elements;\n\t\t\tlet tmp;\n\n\t\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\n\t\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the position component for this matrix from the given vector,\n\t\t * without affecting the rest of the matrix.\n\t\t *\n\t\t * @param {number|Vector3} x - The x component of the vector or alternatively the vector object.\n\t\t * @param {number} y - The y component of the vector.\n\t\t * @param {number} z - The z component of the vector.\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\tsetPosition( x, y, z ) {\n\n\t\t\tconst te = this.elements;\n\n\t\t\tif ( x.isVector3 ) {\n\n\t\t\t\tte[ 12 ] = x.x;\n\t\t\t\tte[ 13 ] = x.y;\n\t\t\t\tte[ 14 ] = x.z;\n\n\t\t\t} else {\n\n\t\t\t\tte[ 12 ] = x;\n\t\t\t\tte[ 13 ] = y;\n\t\t\t\tte[ 14 ] = z;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.\n\t\t * You can not invert with a determinant of zero. If you attempt this, the method produces\n\t\t * a zero matrix instead.\n\t\t *\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\tinvert() {\n\n\t\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\t\tconst te = this.elements,\n\n\t\t\t\tn11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],\n\t\t\t\tn12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],\n\t\t\t\tn13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],\n\t\t\t\tn14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],\n\n\t\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\t\t\tconst det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n\t\t\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n\n\t\t\tconst detInv = 1 / det;\n\n\t\t\tte[ 0 ] = t11 * detInv;\n\t\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\n\t\t\tte[ 4 ] = t12 * detInv;\n\t\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\n\t\t\tte[ 8 ] = t13 * detInv;\n\t\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\n\t\t\tte[ 12 ] = t14 * detInv;\n\t\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Multiplies the columns of this matrix by the given vector.\n\t\t *\n\t\t * @param {Vector3} v - The scale vector.\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\tscale( v ) {\n\n\t\t\tconst te = this.elements;\n\t\t\tconst x = v.x, y = v.y, z = v.z;\n\n\t\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Gets the maximum scale value of the three axes.\n\t\t *\n\t\t * @return {number} The maximum scale.\n\t\t */\n\t\tgetMaxScaleOnAxis() {\n\n\t\t\tconst te = this.elements;\n\n\t\t\tconst scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\t\tconst scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\t\tconst scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\n\t\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\n\t\t}\n\n\t\t/**\n\t\t * Sets this matrix as a translation transform from the given vector.\n\t\t *\n\t\t * @param {number|Vector3} x - The amount to translate in the X axis or alternatively a translation vector.\n\t\t * @param {number} y - The amount to translate in the Y axis.\n\t\t * @param {number} z - The amount to translate in the z axis.\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\tmakeTranslation( x, y, z ) {\n\n\t\t\tif ( x.isVector3 ) {\n\n\t\t\t\tthis.set(\n\n\t\t\t\t\t1, 0, 0, x.x,\n\t\t\t\t\t0, 1, 0, x.y,\n\t\t\t\t\t0, 0, 1, x.z,\n\t\t\t\t\t0, 0, 0, 1\n\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tthis.set(\n\n\t\t\t\t\t1, 0, 0, x,\n\t\t\t\t\t0, 1, 0, y,\n\t\t\t\t\t0, 0, 1, z,\n\t\t\t\t\t0, 0, 0, 1\n\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets this matrix as a rotational transformation around the X axis by\n\t\t * the given angle.\n\t\t *\n\t\t * @param {number} theta - The rotation in radians.\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\tmakeRotationX( theta ) {\n\n\t\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, 0,\n\t\t\t\t0, c, - s, 0,\n\t\t\t\t0, s, c, 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets this matrix as a rotational transformation around the Y axis by\n\t\t * the given angle.\n\t\t *\n\t\t * @param {number} theta - The rotation in radians.\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\tmakeRotationY( theta ) {\n\n\t\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\t\tthis.set(\n\n\t\t\t\t c, 0, s, 0,\n\t\t\t\t 0, 1, 0, 0,\n\t\t\t\t- s, 0, c, 0,\n\t\t\t\t 0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets this matrix as a rotational transformation around the Z axis by\n\t\t * the given angle.\n\t\t *\n\t\t * @param {number} theta - The rotation in radians.\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\tmakeRotationZ( theta ) {\n\n\t\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\t\tthis.set(\n\n\t\t\t\tc, - s, 0, 0,\n\t\t\t\ts, c, 0, 0,\n\t\t\t\t0, 0, 1, 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets this matrix as a rotational transformation around the given axis by\n\t\t * the given angle.\n\t\t *\n\t\t * This is a somewhat controversial but mathematically sound alternative to\n\t\t * rotating via Quaternions. See the discussion [here]{@link https://www.gamedev.net/articles/programming/math-and-physics/do-we-really-need-quaternions-r1199}.\n\t\t *\n\t\t * @param {Vector3} axis - The normalized rotation axis.\n\t\t * @param {number} angle - The rotation in radians.\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\tmakeRotationAxis( axis, angle ) {\n\n\t\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\t\tconst c = Math.cos( angle );\n\t\t\tconst s = Math.sin( angle );\n\t\t\tconst t = 1 - c;\n\t\t\tconst x = axis.x, y = axis.y, z = axis.z;\n\t\t\tconst tx = t * x, ty = t * y;\n\n\t\t\tthis.set(\n\n\t\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets this matrix as a scale transformation.\n\t\t *\n\t\t * @param {number} x - The amount to scale in the X axis.\n\t\t * @param {number} y - The amount to scale in the Y axis.\n\t\t * @param {number} z - The amount to scale in the Z axis.\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\tmakeScale( x, y, z ) {\n\n\t\t\tthis.set(\n\n\t\t\t\tx, 0, 0, 0,\n\t\t\t\t0, y, 0, 0,\n\t\t\t\t0, 0, z, 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets this matrix as a shear transformation.\n\t\t *\n\t\t * @param {number} xy - The amount to shear X by Y.\n\t\t * @param {number} xz - The amount to shear X by Z.\n\t\t * @param {number} yx - The amount to shear Y by X.\n\t\t * @param {number} yz - The amount to shear Y by Z.\n\t\t * @param {number} zx - The amount to shear Z by X.\n\t\t * @param {number} zy - The amount to shear Z by Y.\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\tmakeShear( xy, xz, yx, yz, zx, zy ) {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, yx, zx, 0,\n\t\t\t\txy, 1, zy, 0,\n\t\t\t\txz, yz, 1, 0,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets this matrix to the transformation composed of the given position,\n\t\t * rotation (Quaternion) and scale.\n\t\t *\n\t\t * @param {Vector3} position - The position vector.\n\t\t * @param {Quaternion} quaternion - The rotation as a Quaternion.\n\t\t * @param {Vector3} scale - The scale vector.\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\tcompose( position, quaternion, scale ) {\n\n\t\t\tconst te = this.elements;\n\n\t\t\tconst x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;\n\t\t\tconst x2 = x + x,\ty2 = y + y, z2 = z + z;\n\t\t\tconst xx = x * x2, xy = x * y2, xz = x * z2;\n\t\t\tconst yy = y * y2, yz = y * z2, zz = z * z2;\n\t\t\tconst wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\t\tconst sx = scale.x, sy = scale.y, sz = scale.z;\n\n\t\t\tte[ 0 ] = ( 1 - ( yy + zz ) ) * sx;\n\t\t\tte[ 1 ] = ( xy + wz ) * sx;\n\t\t\tte[ 2 ] = ( xz - wy ) * sx;\n\t\t\tte[ 3 ] = 0;\n\n\t\t\tte[ 4 ] = ( xy - wz ) * sy;\n\t\t\tte[ 5 ] = ( 1 - ( xx + zz ) ) * sy;\n\t\t\tte[ 6 ] = ( yz + wx ) * sy;\n\t\t\tte[ 7 ] = 0;\n\n\t\t\tte[ 8 ] = ( xz + wy ) * sz;\n\t\t\tte[ 9 ] = ( yz - wx ) * sz;\n\t\t\tte[ 10 ] = ( 1 - ( xx + yy ) ) * sz;\n\t\t\tte[ 11 ] = 0;\n\n\t\t\tte[ 12 ] = position.x;\n\t\t\tte[ 13 ] = position.y;\n\t\t\tte[ 14 ] = position.z;\n\t\t\tte[ 15 ] = 1;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Decomposes this matrix into its position, rotation and scale components\n\t\t * and provides the result in the given objects.\n\t\t *\n\t\t * Note: Not all matrices are decomposable in this way. For example, if an\n\t\t * object has a non-uniformly scaled parent, then the object's world matrix\n\t\t * may not be decomposable, and this method may not be appropriate.\n\t\t *\n\t\t * @param {Vector3} position - The position vector.\n\t\t * @param {Quaternion} quaternion - The rotation as a Quaternion.\n\t\t * @param {Vector3} scale - The scale vector.\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\tdecompose( position, quaternion, scale ) {\n\n\t\t\tconst te = this.elements;\n\n\t\t\tlet sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\t\tconst sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\t\tconst sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\n\t\t\t// if determine is negative, we need to invert one scale\n\t\t\tconst det = this.determinant();\n\t\t\tif ( det < 0 ) sx = - sx;\n\n\t\t\tposition.x = te[ 12 ];\n\t\t\tposition.y = te[ 13 ];\n\t\t\tposition.z = te[ 14 ];\n\n\t\t\t// scale the rotation part\n\t\t\t_m1$2.copy( this );\n\n\t\t\tconst invSX = 1 / sx;\n\t\t\tconst invSY = 1 / sy;\n\t\t\tconst invSZ = 1 / sz;\n\n\t\t\t_m1$2.elements[ 0 ] *= invSX;\n\t\t\t_m1$2.elements[ 1 ] *= invSX;\n\t\t\t_m1$2.elements[ 2 ] *= invSX;\n\n\t\t\t_m1$2.elements[ 4 ] *= invSY;\n\t\t\t_m1$2.elements[ 5 ] *= invSY;\n\t\t\t_m1$2.elements[ 6 ] *= invSY;\n\n\t\t\t_m1$2.elements[ 8 ] *= invSZ;\n\t\t\t_m1$2.elements[ 9 ] *= invSZ;\n\t\t\t_m1$2.elements[ 10 ] *= invSZ;\n\n\t\t\tquaternion.setFromRotationMatrix( _m1$2 );\n\n\t\t\tscale.x = sx;\n\t\t\tscale.y = sy;\n\t\t\tscale.z = sz;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Creates a perspective projection matrix. This is used internally by\n\t\t * {@link PerspectiveCamera#updateProjectionMatrix}.\n\n\t\t * @param {number} left - Left boundary of the viewing frustum at the near plane.\n\t\t * @param {number} right - Right boundary of the viewing frustum at the near plane.\n\t\t * @param {number} top - Top boundary of the viewing frustum at the near plane.\n\t\t * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.\n\t\t * @param {number} near - The distance from the camera to the near plane.\n\t\t * @param {number} far - The distance from the camera to the far plane.\n\t\t * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\tmakePerspective( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {\n\n\t\t\tconst te = this.elements;\n\t\t\tconst x = 2 * near / ( right - left );\n\t\t\tconst y = 2 * near / ( top - bottom );\n\n\t\t\tconst a = ( right + left ) / ( right - left );\n\t\t\tconst b = ( top + bottom ) / ( top - bottom );\n\n\t\t\tlet c, d;\n\n\t\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\t\tc = - ( far + near ) / ( far - near );\n\t\t\t\td = ( -2 * far * near ) / ( far - near );\n\n\t\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\t\tc = - far / ( far - near );\n\t\t\t\td = ( - far * near ) / ( far - near );\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t\t}\n\n\t\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a; \tte[ 12 ] = 0;\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b; \tte[ 13 ] = 0;\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c; \tte[ 14 ] = d;\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = -1;\tte[ 15 ] = 0;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Creates a orthographic projection matrix. This is used internally by\n\t\t * {@link OrthographicCamera#updateProjectionMatrix}.\n\n\t\t * @param {number} left - Left boundary of the viewing frustum at the near plane.\n\t\t * @param {number} right - Right boundary of the viewing frustum at the near plane.\n\t\t * @param {number} top - Top boundary of the viewing frustum at the near plane.\n\t\t * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.\n\t\t * @param {number} near - The distance from the camera to the near plane.\n\t\t * @param {number} far - The distance from the camera to the far plane.\n\t\t * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\tmakeOrthographic( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {\n\n\t\t\tconst te = this.elements;\n\t\t\tconst w = 1.0 / ( right - left );\n\t\t\tconst h = 1.0 / ( top - bottom );\n\t\t\tconst p = 1.0 / ( far - near );\n\n\t\t\tconst x = ( right + left ) * w;\n\t\t\tconst y = ( top + bottom ) * h;\n\n\t\t\tlet z, zInv;\n\n\t\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\t\tz = ( far + near ) * p;\n\t\t\t\tzInv = -2 * p;\n\n\t\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\t\tz = near * p;\n\t\t\t\tzInv = -1 * p;\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t\t}\n\n\t\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\t\tte[ 8 ] = 0; \t\tte[ 12 ] = - x;\n\t\t\tte[ 1 ] = 0; \t\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0; \t\tte[ 13 ] = - y;\n\t\t\tte[ 2 ] = 0; \t\tte[ 6 ] = 0;\t\tte[ 10 ] = zInv;\tte[ 14 ] = - z;\n\t\t\tte[ 3 ] = 0; \t\tte[ 7 ] = 0;\t\tte[ 11 ] = 0;\t\tte[ 15 ] = 1;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Returns `true` if this matrix is equal with the given one.\n\t\t *\n\t\t * @param {Matrix4} matrix - The matrix to test for equality.\n\t\t * @return {boolean} Whether this matrix is equal with the given one.\n\t\t */\n\t\tequals( matrix ) {\n\n\t\t\tconst te = this.elements;\n\t\t\tconst me = matrix.elements;\n\n\t\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the elements of the matrix from the given array.\n\t\t *\n\t\t * @param {Array<number>} array - The matrix elements in column-major order.\n\t\t * @param {number} [offset=0] - Index of the first element in the array.\n\t\t * @return {Matrix4} A reference to this matrix.\n\t\t */\n\t\tfromArray( array, offset = 0 ) {\n\n\t\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Writes the elements of this matrix to the given array. If no array is provided,\n\t\t * the method returns a new instance.\n\t\t *\n\t\t * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.\n\t\t * @param {number} [offset=0] - Index of the first element in the array.\n\t\t * @return {Array<number>} The matrix elements in column-major order.\n\t\t */\n\t\ttoArray( array = [], offset = 0 ) {\n\n\t\t\tconst te = this.elements;\n\n\t\t\tarray[ offset ] = te[ 0 ];\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\n\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\n\n\t\t\tarray[ offset + 8 ] = te[ 8 ];\n\t\t\tarray[ offset + 9 ] = te[ 9 ];\n\t\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\t\tarray[ offset + 11 ] = te[ 11 ];\n\n\t\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\t\tarray[ offset + 15 ] = te[ 15 ];\n\n\t\t\treturn array;\n\n\t\t}\n\n\t}\n\n\tconst _v1$5 = /*@__PURE__*/ new Vector3();\n\tconst _m1$2 = /*@__PURE__*/ new Matrix4();\n\tconst _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );\n\tconst _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );\n\tconst _x = /*@__PURE__*/ new Vector3();\n\tconst _y = /*@__PURE__*/ new Vector3();\n\tconst _z = /*@__PURE__*/ new Vector3();\n\n\tconst _matrix$2 = /*@__PURE__*/ new Matrix4();\n\tconst _quaternion$3 = /*@__PURE__*/ new Quaternion();\n\n\t/**\n\t * A class representing Euler angles.\n\t *\n\t * Euler angles describe a rotational transformation by rotating an object on\n\t * its various axes in specified amounts per axis, and a specified axis\n\t * order.\n\t *\n\t * Iterating through an instance will yield its components (x, y, z,\n\t * order) in the corresponding order.\n\t *\n\t * ```js\n\t * const a = new THREE.Euler( 0, 1, 1.57, 'XYZ' );\n\t * const b = new THREE.Vector3( 1, 0, 1 );\n\t * b.applyEuler(a);\n\t * ```\n\t */\n\tclass Euler {\n\n\t\t/**\n\t\t * Constructs a new euler instance.\n\t\t *\n\t\t * @param {number} [x=0] - The angle of the x axis in radians.\n\t\t * @param {number} [y=0] - The angle of the y axis in radians.\n\t\t * @param {number} [z=0] - The angle of the z axis in radians.\n\t\t * @param {string} [order=Euler.DEFAULT_ORDER] - A string representing the order that the rotations are applied.\n\t\t */\n\t\tconstructor( x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER ) {\n\n\t\t\t/**\n\t\t\t * This flag can be used for type testing.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @readonly\n\t\t\t * @default true\n\t\t\t */\n\t\t\tthis.isEuler = true;\n\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._order = order;\n\n\t\t}\n\n\t\t/**\n\t\t * The angle of the x axis in radians.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tget x() {\n\n\t\t\treturn this._x;\n\n\t\t}\n\n\t\tset x( value ) {\n\n\t\t\tthis._x = value;\n\t\t\tthis._onChangeCallback();\n\n\t\t}\n\n\t\t/**\n\t\t * The angle of the y axis in radians.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tget y() {\n\n\t\t\treturn this._y;\n\n\t\t}\n\n\t\tset y( value ) {\n\n\t\t\tthis._y = value;\n\t\t\tthis._onChangeCallback();\n\n\t\t}\n\n\t\t/**\n\t\t * The angle of the z axis in radians.\n\t\t *\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tget z() {\n\n\t\t\treturn this._z;\n\n\t\t}\n\n\t\tset z( value ) {\n\n\t\t\tthis._z = value;\n\t\t\tthis._onChangeCallback();\n\n\t\t}\n\n\t\t/**\n\t\t * A string representing the order that the rotations are applied.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'XYZ'\n\t\t */\n\t\tget order() {\n\n\t\t\treturn this._order;\n\n\t\t}\n\n\t\tset order( value ) {\n\n\t\t\tthis._order = value;\n\t\t\tthis._onChangeCallback();\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the Euler components.\n\t\t *\n\t\t * @param {number} x - The angle of the x axis in radians.\n\t\t * @param {number} y - The angle of the y axis in radians.\n\t\t * @param {number} z - The angle of the z axis in radians.\n\t\t * @param {string} [order] - A string representing the order that the rotations are applied.\n\t\t * @return {Euler} A reference to this Euler instance.\n\t\t */\n\t\tset( x, y, z, order = this._order ) {\n\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._order = order;\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Returns a new Euler instance with copied values from this instance.\n\t\t *\n\t\t * @return {Euler} A clone of this instance.\n\t\t */\n\t\tclone() {\n\n\t\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\n\t\t}\n\n\t\t/**\n\t\t * Copies the values of the given Euler instance to this instance.\n\t\t *\n\t\t * @param {Euler} euler - The Euler instance to copy.\n\t\t * @return {Euler} A reference to this Euler instance.\n\t\t */\n\t\tcopy( euler ) {\n\n\t\t\tthis._x = euler._x;\n\t\t\tthis._y = euler._y;\n\t\t\tthis._z = euler._z;\n\t\t\tthis._order = euler._order;\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the angles of this Euler instance from a pure rotation matrix.\n\t\t *\n\t\t * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).\n\t\t * @param {string} [order] - A string representing the order that the rotations are applied.\n\t\t * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.\n\t\t * @return {Euler} A reference to this Euler instance.\n\t\t */\n\t\tsetFromRotationMatrix( m, order = this._order, update = true ) {\n\n\t\t\tconst te = m.elements;\n\t\t\tconst m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\t\tconst m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\t\tconst m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\t\tswitch ( order ) {\n\n\t\t\t\tcase 'XYZ':\n\n\t\t\t\t\tthis._y = Math.asin( clamp( m13, -1, 1 ) );\n\n\t\t\t\t\tif ( Math.abs( m13 ) < 0.9999999 ) {\n\n\t\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'YXZ':\n\n\t\t\t\t\tthis._x = Math.asin( - clamp( m23, -1, 1 ) );\n\n\t\t\t\t\tif ( Math.abs( m23 ) < 0.9999999 ) {\n\n\t\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ZXY':\n\n\t\t\t\t\tthis._x = Math.asin( clamp( m32, -1, 1 ) );\n\n\t\t\t\t\tif ( Math.abs( m32 ) < 0.9999999 ) {\n\n\t\t\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._y = 0;\n\t\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ZYX':\n\n\t\t\t\t\tthis._y = Math.asin( - clamp( m31, -1, 1 ) );\n\n\t\t\t\t\tif ( Math.abs( m31 ) < 0.9999999 ) {\n\n\t\t\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._x = 0;\n\t\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'YZX':\n\n\t\t\t\t\tthis._z = Math.asin( clamp( m21, -1, 1 ) );\n\n\t\t\t\t\tif ( Math.abs( m21 ) < 0.9999999 ) {\n\n\t\t\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._x = 0;\n\t\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'XZY':\n\n\t\t\t\t\tthis._z = Math.asin( - clamp( m12, -1, 1 ) );\n\n\t\t\t\t\tif ( Math.abs( m12 ) < 0.9999999 ) {\n\n\t\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\t\tthis._y = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );\n\n\t\t\t}\n\n\t\t\tthis._order = order;\n\n\t\t\tif ( update === true ) this._onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the angles of this Euler instance from a normalized quaternion.\n\t\t *\n\t\t * @param {Quaternion} q - A normalized Quaternion.\n\t\t * @param {string} [order] - A string representing the order that the rotations are applied.\n\t\t * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.\n\t\t * @return {Euler} A reference to this Euler instance.\n\t\t */\n\t\tsetFromQuaternion( q, order, update ) {\n\n\t\t\t_matrix$2.makeRotationFromQuaternion( q );\n\n\t\t\treturn this.setFromRotationMatrix( _matrix$2, order, update );\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the angles of this Euler instance from the given vector.\n\t\t *\n\t\t * @param {Vector3} v - The vector.\n\t\t * @param {string} [order] - A string representing the order that the rotations are applied.\n\t\t * @return {Euler} A reference to this Euler instance.\n\t\t */\n\t\tsetFromVector3( v, order = this._order ) {\n\n\t\t\treturn this.set( v.x, v.y, v.z, order );\n\n\t\t}\n\n\t\t/**\n\t\t * Resets the euler angle with a new order by creating a quaternion from this\n\t\t * euler angle and then setting this euler angle with the quaternion and the\n\t\t * new order.\n\t\t *\n\t\t * Warning: This discards revolution information.\n\t\t *\n\t\t * @param {string} [newOrder] - A string representing the new order that the rotations are applied.\n\t\t * @return {Euler} A reference to this Euler instance.\n\t\t */\n\t\treorder( newOrder ) {\n\n\t\t\t_quaternion$3.setFromEuler( this );\n\n\t\t\treturn this.setFromQuaternion( _quaternion$3, newOrder );\n\n\t\t}\n\n\t\t/**\n\t\t * Returns `true` if this Euler instance is equal with the given one.\n\t\t *\n\t\t * @param {Euler} euler - The Euler instance to test for equality.\n\t\t * @return {boolean} Whether this Euler instance is equal with the given one.\n\t\t */\n\t\tequals( euler ) {\n\n\t\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\n\t\t}\n\n\t\t/**\n\t\t * Sets this Euler instance's components to values from the given array. The first three\n\t\t * entries of the array are assign to the x,y and z components. An optional fourth entry\n\t\t * defines the Euler order.\n\t\t *\n\t\t * @param {Array<number,number,number,?string>} array - An array holding the Euler component values.\n\t\t * @return {Euler} A reference to this Euler instance.\n\t\t */\n\t\tfromArray( array ) {\n\n\t\t\tthis._x = array[ 0 ];\n\t\t\tthis._y = array[ 1 ];\n\t\t\tthis._z = array[ 2 ];\n\t\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Writes the components of this Euler instance to the given array. If no array is provided,\n\t\t * the method returns a new instance.\n\t\t *\n\t\t * @param {Array<number,number,number,string>} [array=[]] - The target array holding the Euler components.\n\t\t * @param {number} [offset=0] - Index of the first element in the array.\n\t\t * @return {Array<number,number,number,string>} The Euler components.\n\t\t */\n\t\ttoArray( array = [], offset = 0 ) {\n\n\t\t\tarray[ offset ] = this._x;\n\t\t\tarray[ offset + 1 ] = this._y;\n\t\t\tarray[ offset + 2 ] = this._z;\n\t\t\tarray[ offset + 3 ] = this._order;\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\t_onChange( callback ) {\n\n\t\t\tthis._onChangeCallback = callback;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t_onChangeCallback() {}\n\n\t\t*[ Symbol.iterator ]() {\n\n\t\t\tyield this._x;\n\t\t\tyield this._y;\n\t\t\tyield this._z;\n\t\t\tyield this._order;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The default Euler angle order.\n\t *\n\t * @static\n\t * @type {string}\n\t * @default 'XYZ'\n\t */\n\tEuler.DEFAULT_ORDER = 'XYZ';\n\n\t/**\n\t * A layers object assigns an 3D object to 1 or more of 32\n\t * layers numbered `0` to `31` - internally the layers are stored as a\n\t * bit mask], and by default all 3D objects are a member of layer `0`.\n\t *\n\t * This can be used to control visibility - an object must share a layer with\n\t * a camera to be visible when that camera's view is\n\t * rendered.\n\t *\n\t * All classes that inherit from {@link Object3D} have an `layers` property which\n\t * is an instance of this class.\n\t */\n\tclass Layers {\n\n\t\t/**\n\t\t * Constructs a new layers instance, with membership\n\t\t * initially set to layer `0`.\n\t\t */\n\t\tconstructor() {\n\n\t\t\t/**\n\t\t\t * A bit mask storing which of the 32 layers this layers object is currently\n\t\t\t * a member of.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\tthis.mask = 1 | 0;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets membership to the given layer, and remove membership all other layers.\n\t\t *\n\t\t * @param {number} layer - The layer to set.\n\t\t */\n\t\tset( layer ) {\n\n\t\t\tthis.mask = ( 1 << layer | 0 ) >>> 0;\n\n\t\t}\n\n\t\t/**\n\t\t * Adds membership of the given layer.\n\t\t *\n\t\t * @param {number} layer - The layer to enable.\n\t\t */\n\t\tenable( layer ) {\n\n\t\t\tthis.mask |= 1 << layer | 0;\n\n\t\t}\n\n\t\t/**\n\t\t * Adds membership to all layers.\n\t\t */\n\t\tenableAll() {\n\n\t\t\tthis.mask = 0xffffffff | 0;\n\n\t\t}\n\n\t\t/**\n\t\t * Toggles the membership of the given layer.\n\t\t *\n\t\t * @param {number} layer - The layer to toggle.\n\t\t */\n\t\ttoggle( layer ) {\n\n\t\t\tthis.mask ^= 1 << layer | 0;\n\n\t\t}\n\n\t\t/**\n\t\t * Removes membership of the given layer.\n\t\t *\n\t\t * @param {number} layer - The layer to enable.\n\t\t */\n\t\tdisable( layer ) {\n\n\t\t\tthis.mask &= ~ ( 1 << layer | 0 );\n\n\t\t}\n\n\t\t/**\n\t\t * Removes the membership from all layers.\n\t\t */\n\t\tdisableAll() {\n\n\t\t\tthis.mask = 0;\n\n\t\t}\n\n\t\t/**\n\t\t * Returns `true` if this and the given layers object have at least one\n\t\t * layer in common.\n\t\t *\n\t\t * @param {Layers} layers - The layers to test.\n\t\t * @return {boolean } Whether this and the given layers object have at least one layer in common or not.\n\t\t */\n\t\ttest( layers ) {\n\n\t\t\treturn ( this.mask & layers.mask ) !== 0;\n\n\t\t}\n\n\t\t/**\n\t\t * Returns `true` if the given layer is enabled.\n\t\t *\n\t\t * @param {number} layer - The layer to test.\n\t\t * @return {boolean } Whether the given layer is enabled or not.\n\t\t */\n\t\tisEnabled( layer ) {\n\n\t\t\treturn ( this.mask & ( 1 << layer | 0 ) ) !== 0;\n\n\t\t}\n\n\t}\n\n\tlet _object3DId = 0;\n\n\tconst _v1$4 = /*@__PURE__*/ new Vector3();\n\tconst _q1 = /*@__PURE__*/ new Quaternion();\n\tconst _m1$1 = /*@__PURE__*/ new Matrix4();\n\tconst _target = /*@__PURE__*/ new Vector3();\n\n\tconst _position$3 = /*@__PURE__*/ new Vector3();\n\tconst _scale$2 = /*@__PURE__*/ new Vector3();\n\tconst _quaternion$2 = /*@__PURE__*/ new Quaternion();\n\n\tconst _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );\n\tconst _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );\n\tconst _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );\n\n\t/**\n\t * Fires when the object has been added to its parent object.\n\t *\n\t * @event Object3D#added\n\t * @type {Object}\n\t */\n\tconst _addedEvent = { type: 'added' };\n\n\t/**\n\t * Fires when the object has been removed from its parent object.\n\t *\n\t * @event Object3D#removed\n\t * @type {Object}\n\t */\n\tconst _removedEvent = { type: 'removed' };\n\n\t/**\n\t * Fires when a new child object has been added.\n\t *\n\t * @event Object3D#childadded\n\t * @type {Object}\n\t */\n\tconst _childaddedEvent = { type: 'childadded', child: null };\n\n\t/**\n\t * Fires when a child object has been removed.\n\t *\n\t * @event Object3D#childremoved\n\t * @type {Object}\n\t */\n\tconst _childremovedEvent = { type: 'childremoved', child: null };\n\n\t/**\n\t * This is the base class for most objects in three.js and provides a set of\n\t * properties and methods for manipulating objects in 3D space.\n\t *\n\t * @augments EventDispatcher\n\t */\n\tclass Object3D extends EventDispatcher {\n\n\t\t/**\n\t\t * Constructs a new 3D object.\n\t\t */\n\t\tconstructor() {\n\n\t\t\tsuper();\n\n\t\t\t/**\n\t\t\t * This flag can be used for type testing.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @readonly\n\t\t\t * @default true\n\t\t\t */\n\t\t\tthis.isObject3D = true;\n\n\t\t\t/**\n\t\t\t * The ID of the 3D object.\n\t\t\t *\n\t\t\t * @name Object3D#id\n\t\t\t * @type {number}\n\t\t\t * @readonly\n\t\t\t */\n\t\t\tObject.defineProperty( this, 'id', { value: _object3DId ++ } );\n\n\t\t\t/**\n\t\t\t * The UUID of the 3D object.\n\t\t\t *\n\t\t\t * @type {string}\n\t\t\t * @readonly\n\t\t\t */\n\t\t\tthis.uuid = generateUUID();\n\n\t\t\t/**\n\t\t\t * The name of the 3D object.\n\t\t\t *\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tthis.name = '';\n\n\t\t\t/**\n\t\t\t * The type property is used for detecting the object type\n\t\t\t * in context of serialization/deserialization.\n\t\t\t *\n\t\t\t * @type {string}\n\t\t\t * @readonly\n\t\t\t */\n\t\t\tthis.type = 'Object3D';\n\n\t\t\t/**\n\t\t\t * A reference to the parent object.\n\t\t\t *\n\t\t\t * @type {?Object3D}\n\t\t\t * @default null\n\t\t\t */\n\t\t\tthis.parent = null;\n\n\t\t\t/**\n\t\t\t * An array holding the child 3D objects of this instance.\n\t\t\t *\n\t\t\t * @type {Array<Object3D>}\n\t\t\t */\n\t\t\tthis.children = [];\n\n\t\t\t/**\n\t\t\t * Defines the `up` direction of the 3D object which influences\n\t\t\t * the orientation via methods like {@link Object3D#lookAt}.\n\t\t\t *\n\t\t\t * The default values for all 3D objects is defined by `Object3D.DEFAULT_UP`.\n\t\t\t *\n\t\t\t * @type {Vector3}\n\t\t\t */\n\t\t\tthis.up = Object3D.DEFAULT_UP.clone();\n\n\t\t\tconst position = new Vector3();\n\t\t\tconst rotation = new Euler();\n\t\t\tconst quaternion = new Quaternion();\n\t\t\tconst scale = new Vector3( 1, 1, 1 );\n\n\t\t\tfunction onRotationChange() {\n\n\t\t\t\tquaternion.setFromEuler( rotation, false );\n\n\t\t\t}\n\n\t\t\tfunction onQuaternionChange() {\n\n\t\t\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\n\t\t\t}\n\n\t\t\trotation._onChange( onRotationChange );\n\t\t\tquaternion._onChange( onQuaternionChange );\n\n\t\t\tObject.defineProperties( this, {\n\t\t\t\t/**\n\t\t\t\t * Represents the object's local position.\n\t\t\t\t *\n\t\t\t\t * @name Object3D#position\n\t\t\t\t * @type {Vector3}\n\t\t\t\t * @default (0,0,0)\n\t\t\t\t */\n\t\t\t\tposition: {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: position\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * Represents the object's local rotation as Euler angles, in radians.\n\t\t\t\t *\n\t\t\t\t * @name Object3D#rotation\n\t\t\t\t * @type {Euler}\n\t\t\t\t * @default (0,0,0)\n\t\t\t\t */\n\t\t\t\trotation: {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: rotation\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * Represents the object's local rotation as Quaternions.\n\t\t\t\t *\n\t\t\t\t * @name Object3D#quaternion\n\t\t\t\t * @type {Quaternion}\n\t\t\t\t */\n\t\t\t\tquaternion: {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: quaternion\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * Represents the object's local scale.\n\t\t\t\t *\n\t\t\t\t * @name Object3D#scale\n\t\t\t\t * @type {Vector3}\n\t\t\t\t * @default (1,1,1)\n\t\t\t\t */\n\t\t\t\tscale: {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: scale\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * Represents the object's model-view matrix.\n\t\t\t\t *\n\t\t\t\t * @name Object3D#modelViewMatrix\n\t\t\t\t * @type {Matrix4}\n\t\t\t\t */\n\t\t\t\tmodelViewMatrix: {\n\t\t\t\t\tvalue: new Matrix4()\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * Represents the object's normal matrix.\n\t\t\t\t *\n\t\t\t\t * @name Object3D#normalMatrix\n\t\t\t\t * @type {Matrix3}\n\t\t\t\t */\n\t\t\t\tnormalMatrix: {\n\t\t\t\t\tvalue: new Matrix3()\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\t/**\n\t\t\t * Represents the object's transformation matrix in local space.\n\t\t\t *\n\t\t\t * @type {Matrix4}\n\t\t\t */\n\t\t\tthis.matrix = new Matrix4();\n\n\t\t\t/**\n\t\t\t * Represents the object's transformation matrix in world space.\n\t\t\t * If the 3D object has no parent, then it's identical to the local transformation matrix\n\t\t\t *\n\t\t\t * @type {Matrix4}\n\t\t\t */\n\t\t\tthis.matrixWorld = new Matrix4();\n\n\t\t\t/**\n\t\t\t * When set to `true`, the engine automatically computes the local matrix from position,\n\t\t\t * rotation and scale every frame.\n\t\t\t *\n\t\t\t * The default values for all 3D objects is defined by `Object3D.DEFAULT_MATRIX_AUTO_UPDATE`.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @default true\n\t\t\t */\n\t\t\tthis.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;\n\n\t\t\t/**\n\t\t\t * When set to `true`, the engine automatically computes the world matrix from the current local\n\t\t\t * matrix and the object's transformation hierarchy.\n\t\t\t *\n\t\t\t * The default values for all 3D objects is defined by `Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE`.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @default true\n\t\t\t */\n\t\t\tthis.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer\n\n\t\t\t/**\n\t\t\t * When set to `true`, it calculates the world matrix in that frame and resets this property\n\t\t\t * to `false`.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @default false\n\t\t\t */\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\t/**\n\t\t\t * The layer membership of the 3D object. The 3D object is only visible if it has\n\t\t\t * at least one layer in common with the camera in use. This property can also be\n\t\t\t * used to filter out unwanted objects in ray-intersection tests when using {@link Raycaster}.\n\t\t\t *\n\t\t\t * @type {Layers}\n\t\t\t */\n\t\t\tthis.layers = new Layers();\n\n\t\t\t/**\n\t\t\t * When set to `true`, the 3D object gets rendered.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @default true\n\t\t\t */\n\t\t\tthis.visible = true;\n\n\t\t\t/**\n\t\t\t * When set to `true`, the 3D object gets rendered into shadow maps.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @default false\n\t\t\t */\n\t\t\tthis.castShadow = false;\n\n\t\t\t/**\n\t\t\t * When set to `true`, the 3D object is affected by shadows in the scene.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @default false\n\t\t\t */\n\t\t\tthis.receiveShadow = false;\n\n\t\t\t/**\n\t\t\t * When set to `true`, the 3D object is honored by view frustum culling.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @default true\n\t\t\t */\n\t\t\tthis.frustumCulled = true;\n\n\t\t\t/**\n\t\t\t * This value allows the default rendering order of scene graph objects to be\n\t\t\t * overridden although opaque and transparent objects remain sorted independently.\n\t\t\t * When this property is set for an instance of {@link Group},all descendants\n\t\t\t * objects will be sorted and rendered together. Sorting is from lowest to highest\n\t\t\t * render order.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default 0\n\t\t\t */\n\t\t\tthis.renderOrder = 0;\n\n\t\t\t/**\n\t\t\t * An array holding the animation clips of the 3D object.\n\t\t\t *\n\t\t\t * @type {Array<AnimationClip>}\n\t\t\t */\n\t\t\tthis.animations = [];\n\n\t\t\t/**\n\t\t\t * Custom depth material to be used when rendering to the depth map. Can only be used\n\t\t\t * in context of meshes. When shadow-casting with a {@link DirectionalLight} or {@link SpotLight},\n\t\t\t * if you are modifying vertex positions in the vertex shader you must specify a custom depth\n\t\t\t * material for proper shadows.\n\t\t\t *\n\t\t\t * Only relevant in context of {@link WebGLRenderer}.\n\t\t\t *\n\t\t\t * @type {(Material|undefined)}\n\t\t\t * @default undefined\n\t\t\t */\n\t\t\tthis.customDepthMaterial = undefined;\n\n\t\t\t/**\n\t\t\t * Same as {@link Object3D#customDepthMaterial}, but used with {@link PointLight}.\n\t\t\t *\n\t\t\t * Only relevant in context of {@link WebGLRenderer}.\n\t\t\t *\n\t\t\t * @type {(Material|undefined)}\n\t\t\t * @default undefined\n\t\t\t */\n\t\t\tthis.customDistanceMaterial = undefined;\n\n\t\t\t/**\n\t\t\t * An object that can be used to store custom data about the 3D object. It\n\t\t\t * should not hold references to functions as these will not be cloned.\n\t\t\t *\n\t\t\t * @type {Object}\n\t\t\t */\n\t\t\tthis.userData = {};\n\n\t\t}\n\n\t\t/**\n\t\t * A callback that is executed immediately before a 3D object is rendered to a shadow map.\n\t\t *\n\t\t * @param {Renderer|WebGLRenderer} renderer - The renderer.\n\t\t * @param {Object3D} object - The 3D object.\n\t\t * @param {Camera} camera - The camera that is used to render the scene.\n\t\t * @param {Camera} shadowCamera - The shadow camera.\n\t\t * @param {BufferGeometry} geometry - The 3D object's geometry.\n\t\t * @param {Material} depthMaterial - The depth material.\n\t\t * @param {Object} group - The geometry group data.\n\t\t */\n\t\tonBeforeShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}\n\n\t\t/**\n\t\t * A callback that is executed immediately after a 3D object is rendered to a shadow map.\n\t\t *\n\t\t * @param {Renderer|WebGLRenderer} renderer - The renderer.\n\t\t * @param {Object3D} object - The 3D object.\n\t\t * @param {Camera} camera - The camera that is used to render the scene.\n\t\t * @param {Camera} shadowCamera - The shadow camera.\n\t\t * @param {BufferGeometry} geometry - The 3D object's geometry.\n\t\t * @param {Material} depthMaterial - The depth material.\n\t\t * @param {Object} group - The geometry group data.\n\t\t */\n\t\tonAfterShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}\n\n\t\t/**\n\t\t * A callback that is executed immediately before a 3D object is rendered.\n\t\t *\n\t\t * @param {Renderer|WebGLRenderer} renderer - The renderer.\n\t\t * @param {Object3D} object - The 3D object.\n\t\t * @param {Camera} camera - The camera that is used to render the scene.\n\t\t * @param {BufferGeometry} geometry - The 3D object's geometry.\n\t\t * @param {Material} material - The 3D object's material.\n\t\t * @param {Object} group - The geometry group data.\n\t\t */\n\t\tonBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}\n\n\t\t/**\n\t\t * A callback that is executed immediately after a 3D object is rendered.\n\t\t *\n\t\t * @param {Renderer|WebGLRenderer} renderer - The renderer.\n\t\t * @param {Object3D} object - The 3D object.\n\t\t * @param {Camera} camera - The camera that is used to render the scene.\n\t\t * @param {BufferGeometry} geometry - The 3D object's geometry.\n\t\t * @param {Material} material - The 3D object's material.\n\t\t * @param {Object} group - The geometry group data.\n\t\t */\n\t\tonAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}\n\n\t\t/**\n\t\t * Applies the given transformation matrix to the object and updates the object's position,\n\t\t * rotation and scale.\n\t\t *\n\t\t * @param {Matrix4} matrix - The transformation matrix.\n\t\t */\n\t\tapplyMatrix4( matrix ) {\n\n\t\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\t\tthis.matrix.premultiply( matrix );\n\n\t\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\n\t\t}\n\n\t\t/**\n\t\t * Applies a rotation represented by given the quaternion to the 3D object.\n\t\t *\n\t\t * @param {Quaternion} q - The quaternion.\n\t\t * @return {Object3D} A reference to this instance.\n\t\t */\n\t\tapplyQuaternion( q ) {\n\n\t\t\tthis.quaternion.premultiply( q );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the given rotation represented as an axis/angle couple to the 3D object.\n\t\t *\n\t\t * @param {Vector3} axis - The (normalized) axis vector.\n\t\t * @param {number} angle - The angle in radians.\n\t\t */\n\t\tsetRotationFromAxisAngle( axis, angle ) {\n\n\t\t\t// assumes axis is normalized\n\n\t\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the given rotation represented as Euler angles to the 3D object.\n\t\t *\n\t\t * @param {Euler} euler - The Euler angles.\n\t\t */\n\t\tsetRotationFromEuler( euler ) {\n\n\t\t\tthis.quaternion.setFromEuler( euler, true );\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the given rotation represented as rotation matrix to the 3D object.\n\t\t *\n\t\t * @param {Matrix4} m - Although a 4x4 matrix is expected, the upper 3x3 portion must be\n\t\t * a pure rotation matrix (i.e, unscaled).\n\t\t */\n\t\tsetRotationFromMatrix( m ) {\n\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t\tthis.quaternion.setFromRotationMatrix( m );\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the given rotation represented as a Quaternion to the 3D object.\n\t\t *\n\t\t * @param {Quaternion} q - The Quaternion\n\t\t */\n\t\tsetRotationFromQuaternion( q ) {\n\n\t\t\t// assumes q is normalized\n\n\t\t\tthis.quaternion.copy( q );\n\n\t\t}\n\n\t\t/**\n\t\t * Rotates the 3D object along an axis in local space.\n\t\t *\n\t\t * @param {Vector3} axis - The (normalized) axis vector.\n\t\t * @param {number} angle - The angle in radians.\n\t\t * @return {Object3D} A reference to this instance.\n\t\t */\n\t\trotateOnAxis( axis, angle ) {\n\n\t\t\t// rotate object on axis in object space\n\t\t\t// axis is assumed to be normalized\n\n\t\t\t_q1.setFromAxisAngle( axis, angle );\n\n\t\t\tthis.quaternion.multiply( _q1 );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Rotates the 3D object along an axis in world space.\n\t\t *\n\t\t * @param {Vector3} axis - The (normalized) axis vector.\n\t\t * @param {number} angle - The angle in radians.\n\t\t * @return {Object3D} A reference to this instance.\n\t\t */\n\t\trotateOnWorldAxis( axis, angle ) {\n\n\t\t\t// rotate object on axis in world space\n\t\t\t// axis is assumed to be normalized\n\t\t\t// method assumes no rotated parent\n\n\t\t\t_q1.setFromAxisAngle( axis, angle );\n\n\t\t\tthis.quaternion.premultiply( _q1 );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Rotates the 3D object around its X axis in local space.\n\t\t *\n\t\t * @param {number} angle - The angle in radians.\n\t\t * @return {Object3D} A reference to this instance.\n\t\t */\n\t\trotateX( angle ) {\n\n\t\t\treturn this.rotateOnAxis( _xAxis, angle );\n\n\t\t}\n\n\t\t/**\n\t\t * Rotates the 3D object around its Y axis in local space.\n\t\t *\n\t\t * @param {number} angle - The angle in radians.\n\t\t * @return {Object3D} A reference to this instance.\n\t\t */\n\t\trotateY( angle ) {\n\n\t\t\treturn this.rotateOnAxis( _yAxis, angle );\n\n\t\t}\n\n\t\t/**\n\t\t * Rotates the 3D object around its Z axis in local space.\n\t\t *\n\t\t * @param {number} angle - The angle in radians.\n\t\t * @return {Object3D} A reference to this instance.\n\t\t */\n\t\trotateZ( angle ) {\n\n\t\t\treturn this.rotateOnAxis( _zAxis, angle );\n\n\t\t}\n\n\t\t/**\n\t\t * Translate the 3D object by a distance along the given axis in local space.\n\t\t *\n\t\t * @param {Vector3} axis - The (normalized) axis vector.\n\t\t * @param {number} distance - The distance in world units.\n\t\t * @return {Object3D} A reference to this instance.\n\t\t */\n\t\ttranslateOnAxis( axis, distance ) {\n\n\t\t\t// translate object by distance along axis in object space\n\t\t\t// axis is assumed to be normalized\n\n\t\t\t_v1$4.copy( axis ).applyQuaternion( this.quaternion );\n\n\t\t\tthis.position.add( _v1$4.multiplyScalar( distance ) );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Translate the 3D object by a distance along its X-axis in local space.\n\t\t *\n\t\t * @param {number} distance - The distance in world units.\n\t\t * @return {Object3D} A reference to this instance.\n\t\t */\n\t\ttranslateX( distance ) {\n\n\t\t\treturn this.translateOnAxis( _xAxis, distance );\n\n\t\t}\n\n\t\t/**\n\t\t * Translate the 3D object by a distance along its Y-axis in local space.\n\t\t *\n\t\t * @param {number} distance - The distance in world units.\n\t\t * @return {Object3D} A reference to this instance.\n\t\t */\n\t\ttranslateY( distance ) {\n\n\t\t\treturn this.translateOnAxis( _yAxis, distance );\n\n\t\t}\n\n\t\t/**\n\t\t * Translate the 3D object by a distance along its Z-axis in local space.\n\t\t *\n\t\t * @param {number} distance - The distance in world units.\n\t\t * @return {Object3D} A reference to this instance.\n\t\t */\n\t\ttranslateZ( distance ) {\n\n\t\t\treturn this.translateOnAxis( _zAxis, distance );\n\n\t\t}\n\n\t\t/**\n\t\t * Converts the given vector from this 3D object's local space to world space.\n\t\t *\n\t\t * @param {Vector3} vector - The vector to convert.\n\t\t * @return {Vector3} The converted vector.\n\t\t */\n\t\tlocalToWorld( vector ) {\n\n\t\t\tthis.updateWorldMatrix( true, false );\n\n\t\t\treturn vector.applyMatrix4( this.matrixWorld );\n\n\t\t}\n\n\t\t/**\n\t\t * Converts the given vector from this 3D object's word space to local space.\n\t\t *\n\t\t * @param {Vector3} vector - The vector to convert.\n\t\t * @return {Vector3} The converted vector.\n\t\t */\n\t\tworldToLocal( vector ) {\n\n\t\t\tthis.updateWorldMatrix( true, false );\n\n\t\t\treturn vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );\n\n\t\t}\n\n\t\t/**\n\t\t * Rotates the object to face a point in world space.\n\t\t *\n\t\t * This method does not support objects having non-uniformly-scaled parent(s).\n\t\t *\n\t\t * @param {number|Vector3} x - The x coordinate in world space. Alternatively, a vector representing a position in world space\n\t\t * @param {number} [y] - The y coordinate in world space.\n\t\t * @param {number} [z] - The z coordinate in world space.\n\t\t */\n\t\tlookAt( x, y, z ) {\n\n\t\t\t// This method does not support objects having non-uniformly-scaled parent(s)\n\n\t\t\tif ( x.isVector3 ) {\n\n\t\t\t\t_target.copy( x );\n\n\t\t\t} else {\n\n\t\t\t\t_target.set( x, y, z );\n\n\t\t\t}\n\n\t\t\tconst parent = this.parent;\n\n\t\t\tthis.updateWorldMatrix( true, false );\n\n\t\t\t_position$3.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tif ( this.isCamera || this.isLight ) {\n\n\t\t\t\t_m1$1.lookAt( _position$3, _target, this.up );\n\n\t\t\t} else {\n\n\t\t\t\t_m1$1.lookAt( _target, _position$3, this.up );\n\n\t\t\t}\n\n\t\t\tthis.quaternion.setFromRotationMatrix( _m1$1 );\n\n\t\t\tif ( parent ) {\n\n\t\t\t\t_m1$1.extractRotation( parent.matrixWorld );\n\t\t\t\t_q1.setFromRotationMatrix( _m1$1 );\n\t\t\t\tthis.quaternion.premultiply( _q1.invert() );\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * Adds the given 3D object as a child to this 3D object. An arbitrary number of\n\t\t * objects may be added. Any current parent on an object passed in here will be\n\t\t * removed, since an object can have at most one parent.\n\t\t *\n\t\t * @fires Object3D#added\n\t\t * @fires Object3D#childadded\n\t\t * @param {Object3D} object - The 3D object to add.\n\t\t * @return {Object3D} A reference to this instance.\n\t\t */\n\t\tadd( object ) {\n\n\t\t\tif ( arguments.length > 1 ) {\n\n\t\t\t\tfor ( let i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\t\tthis.add( arguments[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tif ( object === this ) {\n\n\t\t\t\tconsole.error( 'THREE.Object3D.add: object can\\'t be added as a child of itself.', object );\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tif ( object && object.isObject3D ) {\n\n\t\t\t\tobject.removeFromParent();\n\t\t\t\tobject.parent = this;\n\t\t\t\tthis.children.push( object );\n\n\t\t\t\tobject.dispatchEvent( _addedEvent );\n\n\t\t\t\t_childaddedEvent.child = object;\n\t\t\t\tthis.dispatchEvent( _childaddedEvent );\n\t\t\t\t_childaddedEvent.child = null;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Removes the given 3D object as child from this 3D object.\n\t\t * An arbitrary number of objects may be removed.\n\t\t *\n\t\t * @fires Object3D#removed\n\t\t * @fires Object3D#childremoved\n\t\t * @param {Object3D} object - The 3D object to remove.\n\t\t * @return {Object3D} A reference to this instance.\n\t\t */\n\t\tremove( object ) {\n\n\t\t\tif ( arguments.length > 1 ) {\n\n\t\t\t\tfor ( let i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\t\tthis.remove( arguments[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t\tconst index = this.children.indexOf( object );\n\n\t\t\tif ( index !== -1 ) {\n\n\t\t\t\tobject.parent = null;\n\t\t\t\tthis.children.splice( index, 1 );\n\n\t\t\t\tobject.dispatchEvent( _removedEvent );\n\n\t\t\t\t_childremovedEvent.child = object;\n\t\t\t\tthis.dispatchEvent( _childremovedEvent );\n\t\t\t\t_childremovedEvent.child = null;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Removes this 3D object from its current parent.\n\t\t *\n\t\t * @fires Object3D#removed\n\t\t * @fires Object3D#childremoved\n\t\t * @return {Object3D} A reference to this instance.\n\t\t */\n\t\tremoveFromParent() {\n\n\t\t\tconst parent = this.parent;\n\n\t\t\tif ( parent !== null ) {\n\n\t\t\t\tparent.remove( this );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Removes all child objects.\n\t\t *\n\t\t * @fires Object3D#removed\n\t\t * @fires Object3D#childremoved\n\t\t * @return {Object3D} A reference to this instance.\n\t\t */\n\t\tclear() {\n\n\t\t\treturn this.remove( ... this.children );\n\n\t\t}\n\n\t\t/**\n\t\t * Adds the given 3D object as a child of this 3D object, while maintaining the object's world\n\t\t * transform. This method does not support scene graphs having non-uniformly-scaled nodes(s).\n\t\t *\n\t\t * @fires Object3D#added\n\t\t * @fires Object3D#childadded\n\t\t * @param {Object3D} object - The 3D object to attach.\n\t\t * @return {Object3D} A reference to this instance.\n\t\t */\n\t\tattach( object ) {\n\n\t\t\t// adds object as a child of this, while maintaining the object's world transform\n\n\t\t\t// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)\n\n\t\t\tthis.updateWorldMatrix( true, false );\n\n\t\t\t_m1$1.copy( this.matrixWorld ).invert();\n\n\t\t\tif ( object.parent !== null ) {\n\n\t\t\t\tobject.parent.updateWorldMatrix( true, false );\n\n\t\t\t\t_m1$1.multiply( object.parent.matrixWorld );\n\n\t\t\t}\n\n\t\t\tobject.applyMatrix4( _m1$1 );\n\n\t\t\tobject.removeFromParent();\n\t\t\tobject.parent = this;\n\t\t\tthis.children.push( object );\n\n\t\t\tobject.updateWorldMatrix( false, true );\n\n\t\t\tobject.dispatchEvent( _addedEvent );\n\n\t\t\t_childaddedEvent.child = object;\n\t\t\tthis.dispatchEvent( _childaddedEvent );\n\t\t\t_childaddedEvent.child = null;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Searches through the 3D object and its children, starting with the 3D object\n\t\t * itself, and returns the first with a matching ID.\n\t\t *\n\t\t * @param {number} id - The id.\n\t\t * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.\n\t\t */\n\t\tgetObjectById( id ) {\n\n\t\t\treturn this.getObjectByProperty( 'id', id );\n\n\t\t}\n\n\t\t/**\n\t\t * Searches through the 3D object and its children, starting with the 3D object\n\t\t * itself, and returns the first with a matching name.\n\t\t *\n\t\t * @param {string} name - The name.\n\t\t * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.\n\t\t */\n\t\tgetObjectByName( name ) {\n\n\t\t\treturn this.getObjectByProperty( 'name', name );\n\n\t\t}\n\n\t\t/**\n\t\t * Searches through the 3D object and its children, starting with the 3D object\n\t\t * itself, and returns the first with a matching property value.\n\t\t *\n\t\t * @param {string} name - The name of the property.\n\t\t * @param {any} value - The value.\n\t\t * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.\n\t\t */\n\t\tgetObjectByProperty( name, value ) {\n\n\t\t\tif ( this[ name ] === value ) return this;\n\n\t\t\tfor ( let i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = this.children[ i ];\n\t\t\t\tconst object = child.getObjectByProperty( name, value );\n\n\t\t\t\tif ( object !== undefined ) {\n\n\t\t\t\t\treturn object;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn undefined;\n\n\t\t}\n\n\t\t/**\n\t\t * Searches through the 3D object and its children, starting with the 3D object\n\t\t * itself, and returns all 3D objects with a matching property value.\n\t\t *\n\t\t * @param {string} name - The name of the property.\n\t\t * @param {any} value - The value.\n\t\t * @param {Array<Object3D>} result - The method stores the result in this array.\n\t\t * @return {Array<Object3D>} The found 3D objects.\n\t\t */\n\t\tgetObjectsByProperty( name, value, result = [] ) {\n\n\t\t\tif ( this[ name ] === value ) result.push( this );\n\n\t\t\tconst children = this.children;\n\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].getObjectsByProperty( name, value, result );\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\t/**\n\t\t * Returns a vector representing the position of the 3D object in world space.\n\t\t *\n\t\t * @param {Vector3} target - The target vector the result is stored to.\n\t\t * @return {Vector3} The 3D object's position in world space.\n\t\t */\n\t\tgetWorldPosition( target ) {\n\n\t\t\tthis.updateWorldMatrix( true, false );\n\n\t\t\treturn target.setFromMatrixPosition( this.matrixWorld );\n\n\t\t}\n\n\t\t/**\n\t\t * Returns a Quaternion representing the position of the 3D object in world space.\n\t\t *\n\t\t * @param {Quaternion} target - The target Quaternion the result is stored to.\n\t\t * @return {Quaternion} The 3D object's rotation in world space.\n\t\t */\n\t\tgetWorldQuaternion( target ) {\n\n\t\t\tthis.updateWorldMatrix( true, false );\n\n\t\t\tthis.matrixWorld.decompose( _position$3, target, _scale$2 );\n\n\t\t\treturn target;\n\n\t\t}\n\n\t\t/**\n\t\t * Returns a vector representing the scale of the 3D object in world space.\n\t\t *\n\t\t * @param {Vector3} target - The target vector the result is stored to.\n\t\t * @return {Vector3} The 3D object's scale in world space.\n\t\t */\n\t\tgetWorldScale( target ) {\n\n\t\t\tthis.updateWorldMatrix( true, false );\n\n\t\t\tthis.matrixWorld.decompose( _position$3, _quaternion$2, target );\n\n\t\t\treturn target;\n\n\t\t}\n\n\t\t/**\n\t\t * Returns a vector representing the (\"look\") direction of the 3D object in world space.\n\t\t *\n\t\t * @param {Vector3} target - The target vector the result is stored to.\n\t\t * @return {Vector3} The 3D object's direction in world space.\n\t\t */\n\t\tgetWorldDirection( target ) {\n\n\t\t\tthis.updateWorldMatrix( true, false );\n\n\t\t\tconst e = this.matrixWorld.elements;\n\n\t\t\treturn target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();\n\n\t\t}\n\n\t\t/**\n\t\t * Abstract method to get intersections between a casted ray and this\n\t\t * 3D object. Renderable 3D objects such as {@link Mesh}, {@link Line} or {@link Points}\n\t\t * implement this method in order to use raycasting.\n\t\t *\n\t\t * @abstract\n\t\t * @param {Raycaster} raycaster - The raycaster.\n\t\t * @param {Array<Object>} intersects - An array holding the result of the method.\n\t\t */\n\t\traycast( /* raycaster, intersects */ ) {}\n\n\t\t/**\n\t\t * Executes the callback on this 3D object and all descendants.\n\t\t *\n\t\t * Note: Modifying the scene graph inside the callback is discouraged.\n\t\t *\n\t\t * @param {Function} callback - A callback function that allows to process the current 3D object.\n\t\t */\n\t\ttraverse( callback ) {\n\n\t\t\tcallback( this );\n\n\t\t\tconst children = this.children;\n\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].traverse( callback );\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * Like {@link Object3D#traverse}, but the callback will only be executed for visible 3D objects.\n\t\t * Descendants of invisible 3D objects are not traversed.\n\t\t *\n\t\t * Note: Modifying the scene graph inside the callback is discouraged.\n\t\t *\n\t\t * @param {Function} callback - A callback function that allows to process the current 3D object.\n\t\t */\n\t\ttraverseVisible( callback ) {\n\n\t\t\tif ( this.visible === false ) return;\n\n\t\t\tcallback( this );\n\n\t\t\tconst children = this.children;\n\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].traverseVisible( callback );\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * Like {@link Object3D#traverse}, but the callback will only be executed for all ancestors.\n\t\t *\n\t\t * Note: Modifying the scene graph inside the callback is discouraged.\n\t\t *\n\t\t * @param {Function} callback - A callback function that allows to process the current 3D object.\n\t\t */\n\t\ttraverseAncestors( callback ) {\n\n\t\t\tconst parent = this.parent;\n\n\t\t\tif ( parent !== null ) {\n\n\t\t\t\tcallback( parent );\n\n\t\t\t\tparent.traverseAncestors( callback );\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * Updates the transformation matrix in local space by computing it from the current\n\t\t * position, rotation and scale values.\n\t\t */\n\t\tupdateMatrix() {\n\n\t\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\n\t\t\tthis.matrixWorldNeedsUpdate = true;\n\n\t\t}\n\n\t\t/**\n\t\t * Updates the transformation matrix in world space of this 3D objects and its descendants.\n\t\t *\n\t\t * To ensure correct results, this method also recomputes the 3D object's transformation matrix in\n\t\t * local space. The computation of the local and world matrix can be controlled with the\n\t\t * {@link Object3D#matrixAutoUpdate} and {@link Object3D#matrixWorldAutoUpdate} flags which are both\n\t\t * `true` by default.  Set these flags to `false` if you need more control over the update matrix process.\n\t\t *\n\t\t * @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even\n\t\t * when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.\n\t\t */\n\t\tupdateMatrixWorld( force ) {\n\n\t\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\t\tif ( this.matrixWorldNeedsUpdate || force ) {\n\n\t\t\t\tif ( this.matrixWorldAutoUpdate === true ) {\n\n\t\t\t\t\tif ( this.parent === null ) {\n\n\t\t\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\t\tforce = true;\n\n\t\t\t}\n\n\t\t\t// make sure descendants are updated if required\n\n\t\t\tconst children = this.children;\n\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = children[ i ];\n\n\t\t\t\tchild.updateMatrixWorld( force );\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * An alternative version of {@link Object3D#updateMatrixWorld} with more control over the\n\t\t * update of ancestor and descendant nodes.\n\t\t *\n\t\t * @param {boolean} [updateParents=false] Whether ancestor nodes should be updated or not.\n\t\t * @param {boolean} [updateChildren=false] Whether descendant nodes should be updated or not.\n\t\t */\n\t\tupdateWorldMatrix( updateParents, updateChildren ) {\n\n\t\t\tconst parent = this.parent;\n\n\t\t\tif ( updateParents === true && parent !== null ) {\n\n\t\t\t\tparent.updateWorldMatrix( true, false );\n\n\t\t\t}\n\n\t\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\t\tif ( this.matrixWorldAutoUpdate === true ) {\n\n\t\t\t\tif ( this.parent === null ) {\n\n\t\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// make sure descendants are updated\n\n\t\t\tif ( updateChildren === true ) {\n\n\t\t\t\tconst children = this.children;\n\n\t\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst child = children[ i ];\n\n\t\t\t\t\tchild.updateWorldMatrix( false, true );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * Serializes the 3D object into JSON.\n\t\t *\n\t\t * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.\n\t\t * @return {Object} A JSON object representing the serialized 3D object.\n\t\t * @see {@link ObjectLoader#parse}\n\t\t */\n\t\ttoJSON( meta ) {\n\n\t\t\t// meta is a string when called from JSON.stringify\n\t\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\t\tconst output = {};\n\n\t\t\t// meta is a hash used to collect geometries, materials.\n\t\t\t// not providing it implies that this is the root object\n\t\t\t// being serialized.\n\t\t\tif ( isRootObject ) {\n\n\t\t\t\t// initialize meta obj\n\t\t\t\tmeta = {\n\t\t\t\t\tgeometries: {},\n\t\t\t\t\tmaterials: {},\n\t\t\t\t\ttextures: {},\n\t\t\t\t\timages: {},\n\t\t\t\t\tshapes: {},\n\t\t\t\t\tskeletons: {},\n\t\t\t\t\tanimations: {},\n\t\t\t\t\tnodes: {}\n\t\t\t\t};\n\n\t\t\t\toutput.metadata = {\n\t\t\t\t\tversion: 4.7,\n\t\t\t\t\ttype: 'Object',\n\t\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\t// standard Object3D serialization\n\n\t\t\tconst object = {};\n\n\t\t\tobject.uuid = this.uuid;\n\t\t\tobject.type = this.type;\n\n\t\t\tif ( this.name !== '' ) object.name = this.name;\n\t\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\t\tif ( this.visible === false ) object.visible = false;\n\t\t\tif ( this.frustumCulled === false ) object.frustumCulled = false;\n\t\t\tif ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;\n\t\t\tif ( Object.keys( this.userData ).length > 0 ) object.userData = this.userData;\n\n\t\t\tobject.layers = this.layers.mask;\n\t\t\tobject.matrix = this.matrix.toArray();\n\t\t\tobject.up = this.up.toArray();\n\n\t\t\tif ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;\n\n\t\t\t// object specific properties\n\n\t\t\tif ( this.isInstancedMesh ) {\n\n\t\t\t\tobject.type = 'InstancedMesh';\n\t\t\t\tobject.count = this.count;\n\t\t\t\tobject.instanceMatrix = this.instanceMatrix.toJSON();\n\t\t\t\tif ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();\n\n\t\t\t}\n\n\t\t\tif ( this.isBatchedMesh ) {\n\n\t\t\t\tobject.type = 'BatchedMesh';\n\t\t\t\tobject.perObjectFrustumCulled = this.perObjectFrustumCulled;\n\t\t\t\tobject.sortObjects = this.sortObjects;\n\n\t\t\t\tobject.drawRanges = this._drawRanges;\n\t\t\t\tobject.reservedRanges = this._reservedRanges;\n\n\t\t\t\tobject.geometryInfo = this._geometryInfo.map( info => ( {\n\t\t\t\t\t...info,\n\t\t\t\t\tboundingBox: info.boundingBox ? info.boundingBox.toJSON() : undefined,\n\t\t\t\t\tboundingSphere: info.boundingSphere ? info.boundingSphere.toJSON() : undefined\n\t\t\t\t} ) );\n\t\t\t\tobject.instanceInfo = this._instanceInfo.map( info => ( { ...info } ) );\n\n\t\t\t\tobject.availableInstanceIds = this._availableInstanceIds.slice();\n\t\t\t\tobject.availableGeometryIds = this._availableGeometryIds.slice();\n\n\t\t\t\tobject.nextIndexStart = this._nextIndexStart;\n\t\t\t\tobject.nextVertexStart = this._nextVertexStart;\n\t\t\t\tobject.geometryCount = this._geometryCount;\n\n\t\t\t\tobject.maxInstanceCount = this._maxInstanceCount;\n\t\t\t\tobject.maxVertexCount = this._maxVertexCount;\n\t\t\t\tobject.maxIndexCount = this._maxIndexCount;\n\n\t\t\t\tobject.geometryInitialized = this._geometryInitialized;\n\n\t\t\t\tobject.matricesTexture = this._matricesTexture.toJSON( meta );\n\n\t\t\t\tobject.indirectTexture = this._indirectTexture.toJSON( meta );\n\n\t\t\t\tif ( this._colorsTexture !== null ) {\n\n\t\t\t\t\tobject.colorsTexture = this._colorsTexture.toJSON( meta );\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\t\t\tobject.boundingSphere = this.boundingSphere.toJSON();\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.boundingBox !== null ) {\n\n\t\t\t\t\tobject.boundingBox = this.boundingBox.toJSON();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction serialize( library, element ) {\n\n\t\t\t\tif ( library[ element.uuid ] === undefined ) {\n\n\t\t\t\t\tlibrary[ element.uuid ] = element.toJSON( meta );\n\n\t\t\t\t}\n\n\t\t\t\treturn element.uuid;\n\n\t\t\t}\n\n\t\t\tif ( this.isScene ) {\n\n\t\t\t\tif ( this.background ) {\n\n\t\t\t\t\tif ( this.background.isColor ) {\n\n\t\t\t\t\t\tobject.background = this.background.toJSON();\n\n\t\t\t\t\t} else if ( this.background.isTexture ) {\n\n\t\t\t\t\t\tobject.background = this.background.toJSON( meta ).uuid;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true ) {\n\n\t\t\t\t\tobject.environment = this.environment.toJSON( meta ).uuid;\n\n\t\t\t\t}\n\n\t\t\t} else if ( this.isMesh || this.isLine || this.isPoints ) {\n\n\t\t\t\tobject.geometry = serialize( meta.geometries, this.geometry );\n\n\t\t\t\tconst parameters = this.geometry.parameters;\n\n\t\t\t\tif ( parameters !== undefined && parameters.shapes !== undefined ) {\n\n\t\t\t\t\tconst shapes = parameters.shapes;\n\n\t\t\t\t\tif ( Array.isArray( shapes ) ) {\n\n\t\t\t\t\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst shape = shapes[ i ];\n\n\t\t\t\t\t\t\tserialize( meta.shapes, shape );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tserialize( meta.shapes, shapes );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.isSkinnedMesh ) {\n\n\t\t\t\tobject.bindMode = this.bindMode;\n\t\t\t\tobject.bindMatrix = this.bindMatrix.toArray();\n\n\t\t\t\tif ( this.skeleton !== undefined ) {\n\n\t\t\t\t\tserialize( meta.skeletons, this.skeleton );\n\n\t\t\t\t\tobject.skeleton = this.skeleton.uuid;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.material !== undefined ) {\n\n\t\t\t\tif ( Array.isArray( this.material ) ) {\n\n\t\t\t\t\tconst uuids = [];\n\n\t\t\t\t\tfor ( let i = 0, l = this.material.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tuuids.push( serialize( meta.materials, this.material[ i ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject.material = uuids;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tobject.material = serialize( meta.materials, this.material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( this.children.length > 0 ) {\n\n\t\t\t\tobject.children = [];\n\n\t\t\t\tfor ( let i = 0; i < this.children.length; i ++ ) {\n\n\t\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( this.animations.length > 0 ) {\n\n\t\t\t\tobject.animations = [];\n\n\t\t\t\tfor ( let i = 0; i < this.animations.length; i ++ ) {\n\n\t\t\t\t\tconst animation = this.animations[ i ];\n\n\t\t\t\t\tobject.animations.push( serialize( meta.animations, animation ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( isRootObject ) {\n\n\t\t\t\tconst geometries = extractFromCache( meta.geometries );\n\t\t\t\tconst materials = extractFromCache( meta.materials );\n\t\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\t\tconst images = extractFromCache( meta.images );\n\t\t\t\tconst shapes = extractFromCache( meta.shapes );\n\t\t\t\tconst skeletons = extractFromCache( meta.skeletons );\n\t\t\t\tconst animations = extractFromCache( meta.animations );\n\t\t\t\tconst nodes = extractFromCache( meta.nodes );\n\n\t\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\t\tif ( images.length > 0 ) output.images = images;\n\t\t\t\tif ( shapes.length > 0 ) output.shapes = shapes;\n\t\t\t\tif ( skeletons.length > 0 ) output.skeletons = skeletons;\n\t\t\t\tif ( animations.length > 0 ) output.animations = animations;\n\t\t\t\tif ( nodes.length > 0 ) output.nodes = nodes;\n\n\t\t\t}\n\n\t\t\toutput.object = object;\n\n\t\t\treturn output;\n\n\t\t\t// extract data from the cache hash\n\t\t\t// remove metadata on each item\n\t\t\t// and return as array\n\t\t\tfunction extractFromCache( cache ) {\n\n\t\t\t\tconst values = [];\n\t\t\t\tfor ( const key in cache ) {\n\n\t\t\t\t\tconst data = cache[ key ];\n\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\tvalues.push( data );\n\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * Returns a new 3D object with copied values from this instance.\n\t\t *\n\t\t * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are also cloned.\n\t\t * @return {Object3D} A clone of this instance.\n\t\t */\n\t\tclone( recursive ) {\n\n\t\t\treturn new this.constructor().copy( this, recursive );\n\n\t\t}\n\n\t\t/**\n\t\t * Copies the values of the given 3D object to this instance.\n\t\t *\n\t\t * @param {Object3D} source - The 3D object to copy.\n\t\t * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are cloned.\n\t\t * @return {Object3D} A reference to this instance.\n\t\t */\n\t\tcopy( source, recursive = true ) {\n\n\t\t\tthis.name = source.name;\n\n\t\t\tthis.up.copy( source.up );\n\n\t\t\tthis.position.copy( source.position );\n\t\t\tthis.rotation.order = source.rotation.order;\n\t\t\tthis.quaternion.copy( source.quaternion );\n\t\t\tthis.scale.copy( source.scale );\n\n\t\t\tthis.matrix.copy( source.matrix );\n\t\t\tthis.matrixWorld.copy( source.matrixWorld );\n\n\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\t\t\tthis.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;\n\t\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n\t\t\tthis.layers.mask = source.layers.mask;\n\t\t\tthis.visible = source.visible;\n\n\t\t\tthis.castShadow = source.castShadow;\n\t\t\tthis.receiveShadow = source.receiveShadow;\n\n\t\t\tthis.frustumCulled = source.frustumCulled;\n\t\t\tthis.renderOrder = source.renderOrder;\n\n\t\t\tthis.animations = source.animations.slice();\n\n\t\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\t\tif ( recursive === true ) {\n\n\t\t\t\tfor ( let i = 0; i < source.children.length; i ++ ) {\n\n\t\t\t\t\tconst child = source.children[ i ];\n\t\t\t\t\tthis.add( child.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * The default up direction for objects, also used as the default\n\t * position for {@link DirectionalLight} and {@link HemisphereLight}.\n\t *\n\t * @static\n\t * @type {Vector3}\n\t * @default (0,1,0)\n\t */\n\tObject3D.DEFAULT_UP = /*@__PURE__*/ new Vector3( 0, 1, 0 );\n\n\t/**\n\t * The default setting for {@link Object3D#matrixAutoUpdate} for\n\t * newly created 3D objects.\n\t *\n\t * @static\n\t * @type {boolean}\n\t * @default true\n\t */\n\tObject3D.DEFAULT_MATRIX_AUTO_UPDATE = true;\n\n\t/**\n\t * The default setting for {@link Object3D#matrixWorldAutoUpdate} for\n\t * newly created 3D objects.\n\t *\n\t * @static\n\t * @type {boolean}\n\t * @default true\n\t */\n\tObject3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;\n\n\tconst _vector1 = /*@__PURE__*/ new Vector3();\n\tconst _vector2 = /*@__PURE__*/ new Vector3();\n\tconst _normalMatrix = /*@__PURE__*/ new Matrix3();\n\n\t/**\n\t * A two dimensional surface that extends infinitely in 3D space, represented\n\t * in [Hessian normal form]{@link http://mathworld.wolfram.com/HessianNormalForm.html}\n\t * by a unit length normal vector and a constant.\n\t */\n\tclass Plane {\n\n\t\t/**\n\t\t * Constructs a new plane.\n\t\t *\n\t\t * @param {Vector3} [normal=(1,0,0)] - A unit length vector defining the normal of the plane.\n\t\t * @param {number} [constant=0] - The signed distance from the origin to the plane.\n\t\t */\n\t\tconstructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {\n\n\t\t\t/**\n\t\t\t * This flag can be used for type testing.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @readonly\n\t\t\t * @default true\n\t\t\t */\n\t\t\tthis.isPlane = true;\n\n\t\t\t/**\n\t\t\t * A unit length vector defining the normal of the plane.\n\t\t\t *\n\t\t\t * @type {Vector3}\n\t\t\t */\n\t\t\tthis.normal = normal;\n\n\t\t\t/**\n\t\t\t * The signed distance from the origin to the plane.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default 0\n\t\t\t */\n\t\t\tthis.constant = constant;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the plane components by copying the given values.\n\t\t *\n\t\t * @param {Vector3} normal - The normal.\n\t\t * @param {number} constant - The constant.\n\t\t * @return {Plane} A reference to this plane.\n\t\t */\n\t\tset( normal, constant ) {\n\n\t\t\tthis.normal.copy( normal );\n\t\t\tthis.constant = constant;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the plane components by defining `x`, `y`, `z` as the\n\t\t * plane normal and `w` as the constant.\n\t\t *\n\t\t * @param {number} x - The value for the normal's x component.\n\t\t * @param {number} y - The value for the normal's y component.\n\t\t * @param {number} z - The value for the normal's z component.\n\t\t * @param {number} w - The constant value.\n\t\t * @return {Plane} A reference to this plane.\n\t\t */\n\t\tsetComponents( x, y, z, w ) {\n\n\t\t\tthis.normal.set( x, y, z );\n\t\t\tthis.constant = w;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the plane from the given normal and coplanar point (that is a point\n\t\t * that lies onto the plane).\n\t\t *\n\t\t * @param {Vector3} normal - The normal.\n\t\t * @param {Vector3} point - A coplanar point.\n\t\t * @return {Plane} A reference to this plane.\n\t\t */\n\t\tsetFromNormalAndCoplanarPoint( normal, point ) {\n\n\t\t\tthis.normal.copy( normal );\n\t\t\tthis.constant = - point.dot( this.normal );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the plane from three coplanar points. The winding order is\n\t\t * assumed to be counter-clockwise, and determines the direction of\n\t\t * the plane normal.\n\t\t *\n\t\t * @param {Vector3} a - The first coplanar point.\n\t\t * @param {Vector3} b - The second coplanar point.\n\t\t * @param {Vector3} c - The third coplanar point.\n\t\t * @return {Plane} A reference to this plane.\n\t\t */\n\t\tsetFromCoplanarPoints( a, b, c ) {\n\n\t\t\tconst normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();\n\n\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Copies the values of the given plane to this instance.\n\t\t *\n\t\t * @param {Plane} plane - The plane to copy.\n\t\t * @return {Plane} A reference to this plane.\n\t\t */\n\t\tcopy( plane ) {\n\n\t\t\tthis.normal.copy( plane.normal );\n\t\t\tthis.constant = plane.constant;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Normalizes the plane normal and adjusts the constant accordingly.\n\t\t *\n\t\t * @return {Plane} A reference to this plane.\n\t\t */\n\t\tnormalize() {\n\n\t\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\t\tconst inverseNormalLength = 1.0 / this.normal.length();\n\t\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\t\tthis.constant *= inverseNormalLength;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Negates both the plane normal and the constant.\n\t\t *\n\t\t * @return {Plane} A reference to this plane.\n\t\t */\n\t\tnegate() {\n\n\t\t\tthis.constant *= -1;\n\t\t\tthis.normal.negate();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Returns the signed distance from the given point to this plane.\n\t\t *\n\t\t * @param {Vector3} point - The point to compute the distance for.\n\t\t * @return {number} The signed distance.\n\t\t */\n\t\tdistanceToPoint( point ) {\n\n\t\t\treturn this.normal.dot( point ) + this.constant;\n\n\t\t}\n\n\t\t/**\n\t\t * Returns the signed distance from the given sphere to this plane.\n\t\t *\n\t\t * @param {Sphere} sphere - The sphere to compute the distance for.\n\t\t * @return {number} The signed distance.\n\t\t */\n\t\tdistanceToSphere( sphere ) {\n\n\t\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t\t}\n\n\t\t/**\n\t\t * Projects a the given point onto the plane.\n\t\t *\n\t\t * @param {Vector3} point - The point to project.\n\t\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t\t * @return {Vector3} The projected point on the plane.\n\t\t */\n\t\tprojectPoint( point, target ) {\n\n\t\t\treturn target.copy( point ).addScaledVector( this.normal, - this.distanceToPoint( point ) );\n\n\t\t}\n\n\t\t/**\n\t\t * Returns the intersection point of the passed line and the plane. Returns\n\t\t * `null` if the line does not intersect. Returns the line's starting point if\n\t\t * the line is coplanar with the plane.\n\t\t *\n\t\t * @param {Line3} line - The line to compute the intersection for.\n\t\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t\t * @return {?Vector3} The intersection point.\n\t\t */\n\t\tintersectLine( line, target ) {\n\n\t\t\tconst direction = line.delta( _vector1 );\n\n\t\t\tconst denominator = this.normal.dot( direction );\n\n\t\t\tif ( denominator === 0 ) {\n\n\t\t\t\t// line is coplanar, return origin\n\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\t\treturn target.copy( line.start );\n\n\t\t\t\t}\n\n\t\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tconst t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\treturn target.copy( line.start ).addScaledVector( direction, t );\n\n\t\t}\n\n\t\t/**\n\t\t * Returns `true` if the given line segment intersects with (passes through) the plane.\n\t\t *\n\t\t * @param {Line3} line - The line to test.\n\t\t * @return {boolean} Whether the given line segment intersects with the plane or not.\n\t\t */\n\t\tintersectsLine( line ) {\n\n\t\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\t\tconst startSign = this.distanceToPoint( line.start );\n\t\t\tconst endSign = this.distanceToPoint( line.end );\n\n\t\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t\t}\n\n\t\t/**\n\t\t * Returns `true` if the given bounding box intersects with the plane.\n\t\t *\n\t\t * @param {Box3} box - The bounding box to test.\n\t\t * @return {boolean} Whether the given bounding box intersects with the plane or not.\n\t\t */\n\t\tintersectsBox( box ) {\n\n\t\t\treturn box.intersectsPlane( this );\n\n\t\t}\n\n\t\t/**\n\t\t * Returns `true` if the given bounding sphere intersects with the plane.\n\t\t *\n\t\t * @param {Sphere} sphere - The bounding sphere to test.\n\t\t * @return {boolean} Whether the given bounding sphere intersects with the plane or not.\n\t\t */\n\t\tintersectsSphere( sphere ) {\n\n\t\t\treturn sphere.intersectsPlane( this );\n\n\t\t}\n\n\t\t/**\n\t\t * Returns a coplanar vector to the plane, by calculating the\n\t\t * projection of the normal at the origin onto the plane.\n\t\t *\n\t\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t\t * @return {Vector3} The coplanar point.\n\t\t */\n\t\tcoplanarPoint( target ) {\n\n\t\t\treturn target.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t\t}\n\n\t\t/**\n\t\t * Apply a 4x4 matrix to the plane. The matrix must be an affine, homogeneous transform.\n\t\t *\n\t\t * The optional normal matrix can be pre-computed like so:\n\t\t * ```js\n\t\t * const optionalNormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\t\t * ```\n\t\t *\n\t\t * @param {Matrix4} matrix - The transformation matrix.\n\t\t * @param {Matrix4} [optionalNormalMatrix] - A pre-computed normal matrix.\n\t\t * @return {Plane} A reference to this plane.\n\t\t */\n\t\tapplyMatrix4( matrix, optionalNormalMatrix ) {\n\n\t\t\tconst normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );\n\n\t\t\tconst referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );\n\n\t\t\tconst normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Translates the plane by the distance defined by the given offset vector.\n\t\t * Note that this only affects the plane constant and will not affect the normal vector.\n\t\t *\n\t\t * @param {Vector3} offset - The offset vector.\n\t\t * @return {Plane} A reference to this plane.\n\t\t */\n\t\ttranslate( offset ) {\n\n\t\t\tthis.constant -= offset.dot( this.normal );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Returns `true` if this plane is equal with the given one.\n\t\t *\n\t\t * @param {Plane} plane - The plane to test for equality.\n\t\t * @return {boolean} Whether this plane is equal with the given one.\n\t\t */\n\t\tequals( plane ) {\n\n\t\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t\t}\n\n\t\t/**\n\t\t * Returns a new plane with copied values from this instance.\n\t\t *\n\t\t * @return {Plane} A clone of this instance.\n\t\t */\n\t\tclone() {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This class can be used to represent points in 3D space as\n\t * [Spherical coordinates]{@link https://en.wikipedia.org/wiki/Spherical_coordinate_system}.\n\t */\n\tclass Spherical {\n\n\t\t/**\n\t\t * Constructs a new spherical.\n\t\t *\n\t\t * @param {number} [radius=1] - The radius, or the Euclidean distance (straight-line distance) from the point to the origin.\n\t\t * @param {number} [phi=0] - The polar angle in radians from the y (up) axis.\n\t\t * @param {number} [theta=0] - The equator/azimuthal angle in radians around the y (up) axis.\n\t\t */\n\t\tconstructor( radius = 1, phi = 0, theta = 0 ) {\n\n\t\t\t/**\n\t\t\t * The radius, or the Euclidean distance (straight-line distance) from the point to the origin.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default 1\n\t\t\t */\n\t\t\tthis.radius = radius;\n\n\t\t\t/**\n\t\t\t * The polar angle in radians from the y (up) axis.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default 0\n\t\t\t */\n\t\t\tthis.phi = phi;\n\n\t\t\t/**\n\t\t\t * The equator/azimuthal angle in radians around the y (up) axis.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default 0\n\t\t\t */\n\t\t\tthis.theta = theta;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the spherical components by copying the given values.\n\t\t *\n\t\t * @param {number} radius - The radius.\n\t\t * @param {number} phi - The polar angle.\n\t\t * @param {number} theta - The azimuthal angle.\n\t\t * @return {Spherical} A reference to this spherical.\n\t\t */\n\t\tset( radius, phi, theta ) {\n\n\t\t\tthis.radius = radius;\n\t\t\tthis.phi = phi;\n\t\t\tthis.theta = theta;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Copies the values of the given spherical to this instance.\n\t\t *\n\t\t * @param {Spherical} other - The spherical to copy.\n\t\t * @return {Spherical} A reference to this spherical.\n\t\t */\n\t\tcopy( other ) {\n\n\t\t\tthis.radius = other.radius;\n\t\t\tthis.phi = other.phi;\n\t\t\tthis.theta = other.theta;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Restricts the polar angle [page:.phi phi] to be between `0.000001` and pi -\n\t\t * `0.000001`.\n\t\t *\n\t\t * @return {Spherical} A reference to this spherical.\n\t\t */\n\t\tmakeSafe() {\n\n\t\t\tconst EPS = 0.000001;\n\t\t\tthis.phi = clamp( this.phi, EPS, Math.PI - EPS );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the spherical components from the given vector which is assumed to hold\n\t\t * Cartesian coordinates.\n\t\t *\n\t\t * @param {Vector3} v - The vector to set.\n\t\t * @return {Spherical} A reference to this spherical.\n\t\t */\n\t\tsetFromVector3( v ) {\n\n\t\t\treturn this.setFromCartesianCoords( v.x, v.y, v.z );\n\n\t\t}\n\n\t\t/**\n\t\t * Sets the spherical components from the given Cartesian coordinates.\n\t\t *\n\t\t * @param {number} x - The x value.\n\t\t * @param {number} y - The x value.\n\t\t * @param {number} z - The x value.\n\t\t * @return {Spherical} A reference to this spherical.\n\t\t */\n\t\tsetFromCartesianCoords( x, y, z ) {\n\n\t\t\tthis.radius = Math.sqrt( x * x + y * y + z * z );\n\n\t\t\tif ( this.radius === 0 ) {\n\n\t\t\t\tthis.theta = 0;\n\t\t\t\tthis.phi = 0;\n\n\t\t\t} else {\n\n\t\t\t\tthis.theta = Math.atan2( x, z );\n\t\t\t\tthis.phi = Math.acos( clamp( y / this.radius, -1, 1 ) );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t/**\n\t\t * Returns a new spherical with copied values from this instance.\n\t\t *\n\t\t * @return {Spherical} A clone of this instance.\n\t\t */\n\t\tclone() {\n\n\t\t\treturn new this.constructor().copy( this );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Abstract base class for controls.\n\t *\n\t * @abstract\n\t * @augments EventDispatcher\n\t */\n\tclass Controls extends EventDispatcher {\n\n\t\t/**\n\t\t * Constructs a new controls instance.\n\t\t *\n\t\t * @param {Object3D} object - The object that is managed by the controls.\n\t\t * @param {?HTMLDOMElement} domElement - The HTML element used for event listeners.\n\t\t */\n\t\tconstructor( object, domElement = null ) {\n\n\t\t\tsuper();\n\n\t\t\t/**\n\t\t\t * The object that is managed by the controls.\n\t\t\t *\n\t\t\t * @type {Object3D}\n\t\t\t */\n\t\t\tthis.object = object;\n\n\t\t\t/**\n\t\t\t * The HTML element used for event listeners.\n\t\t\t *\n\t\t\t * @type {?HTMLDOMElement}\n\t\t\t * @default null\n\t\t\t */\n\t\t\tthis.domElement = domElement;\n\n\t\t\t/**\n\t\t\t * Whether the controls responds to user input or not.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @default true\n\t\t\t */\n\t\t\tthis.enabled = true;\n\n\t\t\t/**\n\t\t\t * The internal state of the controls.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default -1\n\t\t\t */\n\t\t\tthis.state = -1;\n\n\t\t\t/**\n\t\t\t * This object defines the keyboard input of the controls.\n\t\t\t *\n\t\t\t * @type {Object}\n\t\t\t */\n\t\t\tthis.keys = {};\n\n\t\t\t/**\n\t\t\t * This object defines what type of actions are assigned to the available mouse buttons.\n\t\t\t * It depends on the control implementation what kind of mouse buttons and actions are supported.\n\t\t\t *\n\t\t\t * @type {{LEFT: ?number, MIDDLE: ?number, RIGHT: ?number}}\n\t\t\t */\n\t\t\tthis.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null };\n\n\t\t\t/**\n\t\t\t * This object defines what type of actions are assigned to what kind of touch interaction.\n\t\t\t * It depends on the control implementation what kind of touch interaction and actions are supported.\n\t\t\t *\n\t\t\t * @type {{ONE: ?number, TWO: ?number}}\n\t\t\t */\n\t\t\tthis.touches = { ONE: null, TWO: null };\n\n\t\t}\n\n\t\t/**\n\t\t * Connects the controls to the DOM. This method has so called \"side effects\" since\n\t\t * it adds the module's event listeners to the DOM.\n\t\t *\n\t\t * @param {HTMLDOMElement} element - The DOM element to connect to.\n\t\t */\n\t\tconnect( element ) {\n\n\t\t\tif ( element === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Controls: connect() now requires an element.' ); // @deprecated, the warning can be removed with r185\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( this.domElement !== null ) this.disconnect();\n\n\t\t\tthis.domElement = element;\n\n\t\t}\n\n\t\t/**\n\t\t * Disconnects the controls from the DOM.\n\t\t */\n\t\tdisconnect() {}\n\n\t\t/**\n\t\t * Call this method if you no longer want use to the controls. It frees all internal\n\t\t * resources and removes all event listeners.\n\t\t */\n\t\tdispose() {}\n\n\t\t/**\n\t\t * Controls should implement this method if they have to update their internal state\n\t\t * per simulation step.\n\t\t *\n\t\t * @param {number} [delta] - The time delta in seconds.\n\t\t */\n\t\tupdate( /* delta */ ) {}\n\n\t}\n\n\tif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\n\n\t\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {\n\t\t\trevision: REVISION,\n\t\t} } ) );\n\n\t}\n\n\tif ( typeof window !== 'undefined' ) {\n\n\t\tif ( window.__THREE__ ) {\n\n\t\t\tconsole.warn( 'WARNING: Multiple instances of Three.js being imported.' );\n\n\t\t} else {\n\n\t\t\twindow.__THREE__ = REVISION;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Fires when the camera has been transformed by the controls.\n\t *\n\t * @event OrbitControls#change\n\t * @type {Object}\n\t */\n\tconst _changeEvent = { type: 'change' };\n\n\t/**\n\t * Fires when an interaction was initiated.\n\t *\n\t * @event OrbitControls#start\n\t * @type {Object}\n\t */\n\tconst _startEvent = { type: 'start' };\n\n\t/**\n\t * Fires when an interaction has finished.\n\t *\n\t * @event OrbitControls#end\n\t * @type {Object}\n\t */\n\tconst _endEvent = { type: 'end' };\n\n\tconst _ray = new Ray();\n\tconst _plane = new Plane();\n\tconst _TILT_LIMIT = Math.cos( 70 * MathUtils.DEG2RAD );\n\n\tconst _v = new Vector3();\n\tconst _twoPI = 2 * Math.PI;\n\n\tconst _STATE = {\n\t\tNONE: -1,\n\t\tROTATE: 0,\n\t\tDOLLY: 1,\n\t\tPAN: 2,\n\t\tTOUCH_ROTATE: 3,\n\t\tTOUCH_PAN: 4,\n\t\tTOUCH_DOLLY_PAN: 5,\n\t\tTOUCH_DOLLY_ROTATE: 6\n\t};\n\tconst _EPS = 0.000001;\n\n\n\t/**\n\t * Orbit controls allow the camera to orbit around a target.\n\t *\n\t * OrbitControls performs orbiting, dollying (zooming), and panning. Unlike {@link TrackballControls},\n\t * it maintains the \"up\" direction `object.up` (+Y by default).\n\t *\n\t * - Orbit: Left mouse / touch: one-finger move.\n\t * - Zoom: Middle mouse, or mousewheel / touch: two-finger spread or squish.\n\t * - Pan: Right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move.\n\t *\n\t * ```js\n\t * const controls = new OrbitControls( camera, renderer.domElement );\n\t *\n\t * // controls.update() must be called after any manual changes to the camera's transform\n\t * camera.position.set( 0, 20, 100 );\n\t * controls.update();\n\t *\n\t * function animate() {\n\t *\n\t * \t// required if controls.enableDamping or controls.autoRotate are set to true\n\t * \tcontrols.update();\n\t *\n\t * \trenderer.render( scene, camera );\n\t *\n\t * }\n\t * ```\n\t *\n\t * @augments Controls\n\t * @three_import import { OrbitControls } from 'three/addons/controls/OrbitControls.js';\n\t */\n\tclass OrbitControls extends Controls {\n\n\t\t/**\n\t\t * Constructs a new controls instance.\n\t\t *\n\t\t * @param {Object3D} object - The object that is managed by the controls.\n\t\t * @param {?HTMLDOMElement} domElement - The HTML element used for event listeners.\n\t\t */\n\t\tconstructor( object, domElement = null ) {\n\n\t\t\tsuper( object, domElement );\n\n\t\t\tthis.state = _STATE.NONE;\n\n\t\t\t/**\n\t\t\t * The focus point of the controls, the `object` orbits around this.\n\t\t\t * It can be updated manually at any point to change the focus of the controls.\n\t\t\t *\n\t\t\t * @type {Vector3}\n\t\t\t */\n\t\t\tthis.target = new Vector3();\n\n\t\t\t/**\n\t\t\t * The focus point of the `minTargetRadius` and `maxTargetRadius` limits.\n\t\t\t * It can be updated manually at any point to change the center of interest\n\t\t\t * for the `target`.\n\t\t\t *\n\t\t\t * @type {Vector3}\n\t\t\t */\n\t\t\tthis.cursor = new Vector3();\n\n\t\t\t/**\n\t\t\t * How far you can dolly in (perspective camera only).\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default 0\n\t\t\t */\n\t\t\tthis.minDistance = 0;\n\n\t\t\t/**\n\t\t\t * How far you can dolly out (perspective camera only).\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default Infinity\n\t\t\t */\n\t\t\tthis.maxDistance = Infinity;\n\n\t\t\t/**\n\t\t\t * How far you can zoom in (orthographic camera only).\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default 0\n\t\t\t */\n\t\t\tthis.minZoom = 0;\n\n\t\t\t/**\n\t\t\t * How far you can zoom out (orthographic camera only).\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default Infinity\n\t\t\t */\n\t\t\tthis.maxZoom = Infinity;\n\n\t\t\t/**\n\t\t\t * How close you can get the target to the 3D `cursor`.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default 0\n\t\t\t */\n\t\t\tthis.minTargetRadius = 0;\n\n\t\t\t/**\n\t\t\t * How far you can move the target from the 3D `cursor`.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default Infinity\n\t\t\t */\n\t\t\tthis.maxTargetRadius = Infinity;\n\n\t\t\t/**\n\t\t\t * How far you can orbit vertically, lower limit. Range is `[0, Math.PI]` radians.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default 0\n\t\t\t */\n\t\t\tthis.minPolarAngle = 0;\n\n\t\t\t/**\n\t\t\t * How far you can orbit vertically, upper limit. Range is `[0, Math.PI]` radians.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default Math.PI\n\t\t\t */\n\t\t\tthis.maxPolarAngle = Math.PI;\n\n\t\t\t/**\n\t\t\t * How far you can orbit horizontally, lower limit. If set, the interval `[ min, max ]`\n\t\t\t * must be a sub-interval of `[ - 2 PI, 2 PI ]`, with `( max - min < 2 PI )`.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default -Infinity\n\t\t\t */\n\t\t\tthis.minAzimuthAngle = - Infinity;\n\n\t\t\t/**\n\t\t\t * How far you can orbit horizontally, upper limit. If set, the interval `[ min, max ]`\n\t\t\t * must be a sub-interval of `[ - 2 PI, 2 PI ]`, with `( max - min < 2 PI )`.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default -Infinity\n\t\t\t */\n\t\t\tthis.maxAzimuthAngle = Infinity;\n\n\t\t\t/**\n\t\t\t * Set to `true` to enable damping (inertia), which can be used to give a sense of weight\n\t\t\t * to the controls. Note that if this is enabled, you must call `update()` in your animation\n\t\t\t * loop.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @default false\n\t\t\t */\n\t\t\tthis.enableDamping = false;\n\n\t\t\t/**\n\t\t\t * The damping inertia used if `enableDamping` is set to `true`.\n\t\t\t *\n\t\t\t * Note that for this to work, you must call `update()` in your animation loop.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default 0.05\n\t\t\t */\n\t\t\tthis.dampingFactor = 0.05;\n\n\t\t\t/**\n\t\t\t * Enable or disable zooming (dollying) of the camera.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @default true\n\t\t\t */\n\t\t\tthis.enableZoom = true;\n\n\t\t\t/**\n\t\t\t * Speed of zooming / dollying.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default 1\n\t\t\t */\n\t\t\tthis.zoomSpeed = 1.0;\n\n\t\t\t/**\n\t\t\t * Enable or disable horizontal and vertical rotation of the camera.\n\t\t\t *\n\t\t\t * Note that it is possible to disable a single axis by setting the min and max of the\n\t\t\t * `minPolarAngle` or `minAzimuthAngle` to the same value, which will cause the vertical\n\t\t\t * or horizontal rotation to be fixed at that value.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @default true\n\t\t\t */\n\t\t\tthis.enableRotate = true;\n\n\t\t\t/**\n\t\t\t * Speed of rotation.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default 1\n\t\t\t */\n\t\t\tthis.rotateSpeed = 1.0;\n\n\t\t\t/**\n\t\t\t * How fast to rotate the camera when the keyboard is used.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default 1\n\t\t\t */\n\t\t\tthis.keyRotateSpeed = 1.0;\n\n\t\t\t/**\n\t\t\t * Enable or disable camera panning.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @default true\n\t\t\t */\n\t\t\tthis.enablePan = true;\n\n\t\t\t/**\n\t\t\t * Speed of panning.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default 1\n\t\t\t */\n\t\t\tthis.panSpeed = 1.0;\n\n\t\t\t/**\n\t\t\t * Defines how the camera's position is translated when panning. If `true`, the camera pans\n\t\t\t * in screen space. Otherwise, the camera pans in the plane orthogonal to the camera's up\n\t\t\t * direction.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @default true\n\t\t\t */\n\t\t\tthis.screenSpacePanning = true;\n\n\t\t\t/**\n\t\t\t * How fast to pan the camera when the keyboard is used in\n\t\t\t * pixels per keypress.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default 7\n\t\t\t */\n\t\t\tthis.keyPanSpeed = 7.0;\n\n\t\t\t/**\n\t\t\t * Setting this property to `true` allows to zoom to the cursor's position.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @default false\n\t\t\t */\n\t\t\tthis.zoomToCursor = false;\n\n\t\t\t/**\n\t\t\t * Set to true to automatically rotate around the target\n\t\t\t *\n\t\t\t * Note that if this is enabled, you must call `update()` in your animation loop.\n\t\t\t * If you want the auto-rotate speed to be independent of the frame rate (the refresh\n\t\t\t * rate of the display), you must pass the time `deltaTime`, in seconds, to `update()`.\n\t\t\t *\n\t\t\t * @type {boolean}\n\t\t\t * @default false\n\t\t\t */\n\t\t\tthis.autoRotate = false;\n\n\t\t\t/**\n\t\t\t * How fast to rotate around the target if `autoRotate` is `true`. The default  equates to 30 seconds\n\t\t\t * per orbit at 60fps.\n\t\t\t *\n\t\t\t * Note that if `autoRotate` is enabled, you must call `update()` in your animation loop.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t * @default 2\n\t\t\t */\n\t\t\tthis.autoRotateSpeed = 2.0;\n\n\t\t\t/**\n\t\t\t * This object contains references to the keycodes for controlling camera panning.\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * controls.keys = {\n\t\t\t * \tLEFT: 'ArrowLeft', //left arrow\n\t\t\t * \tUP: 'ArrowUp', // up arrow\n\t\t\t * \tRIGHT: 'ArrowRight', // right arrow\n\t\t\t * \tBOTTOM: 'ArrowDown' // down arrow\n\t\t\t * }\n\t\t\t * ```\n\t\t\t * @type {Object}\n\t\t\t */\n\t\t\tthis.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };\n\n\t\t\t/**\n\t\t\t * This object contains references to the mouse actions used by the controls.\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * controls.mouseButtons = {\n\t\t\t * \tLEFT: THREE.MOUSE.ROTATE,\n\t\t\t * \tMIDDLE: THREE.MOUSE.DOLLY,\n\t\t\t * \tRIGHT: THREE.MOUSE.PAN\n\t\t\t * }\n\t\t\t * ```\n\t\t\t * @type {Object}\n\t\t\t */\n\t\t\tthis.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };\n\n\t\t\t/**\n\t\t\t * This object contains references to the touch actions used by the controls.\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * controls.mouseButtons = {\n\t\t\t * \tONE: THREE.TOUCH.ROTATE,\n\t\t\t * \tTWO: THREE.TOUCH.DOLLY_PAN\n\t\t\t * }\n\t\t\t * ```\n\t\t\t * @type {Object}\n\t\t\t */\n\t\t\tthis.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };\n\n\t\t\t/**\n\t\t\t * Used internally by `saveState()` and `reset()`.\n\t\t\t *\n\t\t\t * @type {Vector3}\n\t\t\t */\n\t\t\tthis.target0 = this.target.clone();\n\n\t\t\t/**\n\t\t\t * Used internally by `saveState()` and `reset()`.\n\t\t\t *\n\t\t\t * @type {Vector3}\n\t\t\t */\n\t\t\tthis.position0 = this.object.position.clone();\n\n\t\t\t/**\n\t\t\t * Used internally by `saveState()` and `reset()`.\n\t\t\t *\n\t\t\t * @type {number}\n\t\t\t */\n\t\t\tthis.zoom0 = this.object.zoom;\n\n\t\t\t// the target DOM element for key events\n\t\t\tthis._domElementKeyEvents = null;\n\n\t\t\t// internals\n\n\t\t\tthis._lastPosition = new Vector3();\n\t\t\tthis._lastQuaternion = new Quaternion();\n\t\t\tthis._lastTargetPosition = new Vector3();\n\n\t\t\t// so camera.up is the orbit axis\n\t\t\tthis._quat = new Quaternion().setFromUnitVectors( object.up, new Vector3( 0, 1, 0 ) );\n\t\t\tthis._quatInverse = this._quat.clone().invert();\n\n\t\t\t// current position in spherical coordinates\n\t\t\tthis._spherical = new Spherical();\n\t\t\tthis._sphericalDelta = new Spherical();\n\n\t\t\tthis._scale = 1;\n\t\t\tthis._panOffset = new Vector3();\n\n\t\t\tthis._rotateStart = new Vector2();\n\t\t\tthis._rotateEnd = new Vector2();\n\t\t\tthis._rotateDelta = new Vector2();\n\n\t\t\tthis._panStart = new Vector2();\n\t\t\tthis._panEnd = new Vector2();\n\t\t\tthis._panDelta = new Vector2();\n\n\t\t\tthis._dollyStart = new Vector2();\n\t\t\tthis._dollyEnd = new Vector2();\n\t\t\tthis._dollyDelta = new Vector2();\n\n\t\t\tthis._dollyDirection = new Vector3();\n\t\t\tthis._mouse = new Vector2();\n\t\t\tthis._performCursorZoom = false;\n\n\t\t\tthis._pointers = [];\n\t\t\tthis._pointerPositions = {};\n\n\t\t\tthis._controlActive = false;\n\n\t\t\t// event listeners\n\n\t\t\tthis._onPointerMove = onPointerMove.bind( this );\n\t\t\tthis._onPointerDown = onPointerDown.bind( this );\n\t\t\tthis._onPointerUp = onPointerUp.bind( this );\n\t\t\tthis._onContextMenu = onContextMenu.bind( this );\n\t\t\tthis._onMouseWheel = onMouseWheel.bind( this );\n\t\t\tthis._onKeyDown = onKeyDown.bind( this );\n\n\t\t\tthis._onTouchStart = onTouchStart.bind( this );\n\t\t\tthis._onTouchMove = onTouchMove.bind( this );\n\n\t\t\tthis._onMouseDown = onMouseDown.bind( this );\n\t\t\tthis._onMouseMove = onMouseMove.bind( this );\n\n\t\t\tthis._interceptControlDown = interceptControlDown.bind( this );\n\t\t\tthis._interceptControlUp = interceptControlUp.bind( this );\n\n\t\t\t//\n\n\t\t\tif ( this.domElement !== null ) {\n\n\t\t\t\tthis.connect( this.domElement );\n\n\t\t\t}\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tconnect( element ) {\n\n\t\t\tsuper.connect( element );\n\n\t\t\tthis.domElement.addEventListener( 'pointerdown', this._onPointerDown );\n\t\t\tthis.domElement.addEventListener( 'pointercancel', this._onPointerUp );\n\n\t\t\tthis.domElement.addEventListener( 'contextmenu', this._onContextMenu );\n\t\t\tthis.domElement.addEventListener( 'wheel', this._onMouseWheel, { passive: false } );\n\n\t\t\tconst document = this.domElement.getRootNode(); // offscreen canvas compatibility\n\t\t\tdocument.addEventListener( 'keydown', this._interceptControlDown, { passive: true, capture: true } );\n\n\t\t\tthis.domElement.style.touchAction = 'none'; // disable touch scroll\n\n\t\t}\n\n\t\tdisconnect() {\n\n\t\t\tthis.domElement.removeEventListener( 'pointerdown', this._onPointerDown );\n\t\t\tthis.domElement.removeEventListener( 'pointermove', this._onPointerMove );\n\t\t\tthis.domElement.removeEventListener( 'pointerup', this._onPointerUp );\n\t\t\tthis.domElement.removeEventListener( 'pointercancel', this._onPointerUp );\n\n\t\t\tthis.domElement.removeEventListener( 'wheel', this._onMouseWheel );\n\t\t\tthis.domElement.removeEventListener( 'contextmenu', this._onContextMenu );\n\n\t\t\tthis.stopListenToKeyEvents();\n\n\t\t\tconst document = this.domElement.getRootNode(); // offscreen canvas compatibility\n\t\t\tdocument.removeEventListener( 'keydown', this._interceptControlDown, { capture: true } );\n\n\t\t\tthis.domElement.style.touchAction = 'auto';\n\n\t\t}\n\n\t\tdispose() {\n\n\t\t\tthis.disconnect();\n\n\t\t}\n\n\t\t/**\n\t\t * Get the current vertical rotation, in radians.\n\t\t *\n\t\t * @return {number} The current vertical rotation, in radians.\n\t\t */\n\t\tgetPolarAngle() {\n\n\t\t\treturn this._spherical.phi;\n\n\t\t}\n\n\t\t/**\n\t\t * Get the current horizontal rotation, in radians.\n\t\t *\n\t\t * @return {number} The current horizontal rotation, in radians.\n\t\t */\n\t\tgetAzimuthalAngle() {\n\n\t\t\treturn this._spherical.theta;\n\n\t\t}\n\n\t\t/**\n\t\t * Returns the distance from the camera to the target.\n\t\t *\n\t\t * @return {number} The distance from the camera to the target.\n\t\t */\n\t\tgetDistance() {\n\n\t\t\treturn this.object.position.distanceTo( this.target );\n\n\t\t}\n\n\t\t/**\n\t\t * Adds key event listeners to the given DOM element.\n\t\t * `window` is a recommended argument for using this method.\n\t\t *\n\t\t * @param {HTMLDOMElement} domElement - The DOM element\n\t\t */\n\t\tlistenToKeyEvents( domElement ) {\n\n\t\t\tdomElement.addEventListener( 'keydown', this._onKeyDown );\n\t\t\tthis._domElementKeyEvents = domElement;\n\n\t\t}\n\n\t\t/**\n\t\t * Removes the key event listener previously defined with `listenToKeyEvents()`.\n\t\t */\n\t\tstopListenToKeyEvents() {\n\n\t\t\tif ( this._domElementKeyEvents !== null ) {\n\n\t\t\t\tthis._domElementKeyEvents.removeEventListener( 'keydown', this._onKeyDown );\n\t\t\t\tthis._domElementKeyEvents = null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * Save the current state of the controls. This can later be recovered with `reset()`.\n\t\t */\n\t\tsaveState() {\n\n\t\t\tthis.target0.copy( this.target );\n\t\t\tthis.position0.copy( this.object.position );\n\t\t\tthis.zoom0 = this.object.zoom;\n\n\t\t}\n\n\t\t/**\n\t\t * Reset the controls to their state from either the last time the `saveState()`\n\t\t * was called, or the initial state.\n\t\t */\n\t\treset() {\n\n\t\t\tthis.target.copy( this.target0 );\n\t\t\tthis.object.position.copy( this.position0 );\n\t\t\tthis.object.zoom = this.zoom0;\n\n\t\t\tthis.object.updateProjectionMatrix();\n\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\tthis.update();\n\n\t\t\tthis.state = _STATE.NONE;\n\n\t\t}\n\n\t\tupdate( deltaTime = null ) {\n\n\t\t\tconst position = this.object.position;\n\n\t\t\t_v.copy( position ).sub( this.target );\n\n\t\t\t// rotate offset to \"y-axis-is-up\" space\n\t\t\t_v.applyQuaternion( this._quat );\n\n\t\t\t// angle from z-axis around y-axis\n\t\t\tthis._spherical.setFromVector3( _v );\n\n\t\t\tif ( this.autoRotate && this.state === _STATE.NONE ) {\n\n\t\t\t\tthis._rotateLeft( this._getAutoRotationAngle( deltaTime ) );\n\n\t\t\t}\n\n\t\t\tif ( this.enableDamping ) {\n\n\t\t\t\tthis._spherical.theta += this._sphericalDelta.theta * this.dampingFactor;\n\t\t\t\tthis._spherical.phi += this._sphericalDelta.phi * this.dampingFactor;\n\n\t\t\t} else {\n\n\t\t\t\tthis._spherical.theta += this._sphericalDelta.theta;\n\t\t\t\tthis._spherical.phi += this._sphericalDelta.phi;\n\n\t\t\t}\n\n\t\t\t// restrict theta to be between desired limits\n\n\t\t\tlet min = this.minAzimuthAngle;\n\t\t\tlet max = this.maxAzimuthAngle;\n\n\t\t\tif ( isFinite( min ) && isFinite( max ) ) {\n\n\t\t\t\tif ( min < - Math.PI ) min += _twoPI; else if ( min > Math.PI ) min -= _twoPI;\n\n\t\t\t\tif ( max < - Math.PI ) max += _twoPI; else if ( max > Math.PI ) max -= _twoPI;\n\n\t\t\t\tif ( min <= max ) {\n\n\t\t\t\t\tthis._spherical.theta = Math.max( min, Math.min( max, this._spherical.theta ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._spherical.theta = ( this._spherical.theta > ( min + max ) / 2 ) ?\n\t\t\t\t\t\tMath.max( min, this._spherical.theta ) :\n\t\t\t\t\t\tMath.min( max, this._spherical.theta );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// restrict phi to be between desired limits\n\t\t\tthis._spherical.phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, this._spherical.phi ) );\n\n\t\t\tthis._spherical.makeSafe();\n\n\n\t\t\t// move target to panned location\n\n\t\t\tif ( this.enableDamping === true ) {\n\n\t\t\t\tthis.target.addScaledVector( this._panOffset, this.dampingFactor );\n\n\t\t\t} else {\n\n\t\t\t\tthis.target.add( this._panOffset );\n\n\t\t\t}\n\n\t\t\t// Limit the target distance from the cursor to create a sphere around the center of interest\n\t\t\tthis.target.sub( this.cursor );\n\t\t\tthis.target.clampLength( this.minTargetRadius, this.maxTargetRadius );\n\t\t\tthis.target.add( this.cursor );\n\n\t\t\tlet zoomChanged = false;\n\t\t\t// adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera\n\t\t\t// we adjust zoom later in these cases\n\t\t\tif ( this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera ) {\n\n\t\t\t\tthis._spherical.radius = this._clampDistance( this._spherical.radius );\n\n\t\t\t} else {\n\n\t\t\t\tconst prevRadius = this._spherical.radius;\n\t\t\t\tthis._spherical.radius = this._clampDistance( this._spherical.radius * this._scale );\n\t\t\t\tzoomChanged = prevRadius != this._spherical.radius;\n\n\t\t\t}\n\n\t\t\t_v.setFromSpherical( this._spherical );\n\n\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\t\t_v.applyQuaternion( this._quatInverse );\n\n\t\t\tposition.copy( this.target ).add( _v );\n\n\t\t\tthis.object.lookAt( this.target );\n\n\t\t\tif ( this.enableDamping === true ) {\n\n\t\t\t\tthis._sphericalDelta.theta *= ( 1 - this.dampingFactor );\n\t\t\t\tthis._sphericalDelta.phi *= ( 1 - this.dampingFactor );\n\n\t\t\t\tthis._panOffset.multiplyScalar( 1 - this.dampingFactor );\n\n\t\t\t} else {\n\n\t\t\t\tthis._sphericalDelta.set( 0, 0, 0 );\n\n\t\t\t\tthis._panOffset.set( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t\t// adjust camera position\n\t\t\tif ( this.zoomToCursor && this._performCursorZoom ) {\n\n\t\t\t\tlet newRadius = null;\n\t\t\t\tif ( this.object.isPerspectiveCamera ) {\n\n\t\t\t\t\t// move the camera down the pointer ray\n\t\t\t\t\t// this method avoids floating point error\n\t\t\t\t\tconst prevRadius = _v.length();\n\t\t\t\t\tnewRadius = this._clampDistance( prevRadius * this._scale );\n\n\t\t\t\t\tconst radiusDelta = prevRadius - newRadius;\n\t\t\t\t\tthis.object.position.addScaledVector( this._dollyDirection, radiusDelta );\n\t\t\t\t\tthis.object.updateMatrixWorld();\n\n\t\t\t\t\tzoomChanged = !! radiusDelta;\n\n\t\t\t\t} else if ( this.object.isOrthographicCamera ) {\n\n\t\t\t\t\t// adjust the ortho camera position based on zoom changes\n\t\t\t\t\tconst mouseBefore = new Vector3( this._mouse.x, this._mouse.y, 0 );\n\t\t\t\t\tmouseBefore.unproject( this.object );\n\n\t\t\t\t\tconst prevZoom = this.object.zoom;\n\t\t\t\t\tthis.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom / this._scale ) );\n\t\t\t\t\tthis.object.updateProjectionMatrix();\n\n\t\t\t\t\tzoomChanged = prevZoom !== this.object.zoom;\n\n\t\t\t\t\tconst mouseAfter = new Vector3( this._mouse.x, this._mouse.y, 0 );\n\t\t\t\t\tmouseAfter.unproject( this.object );\n\n\t\t\t\t\tthis.object.position.sub( mouseAfter ).add( mouseBefore );\n\t\t\t\t\tthis.object.updateMatrixWorld();\n\n\t\t\t\t\tnewRadius = _v.length();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.' );\n\t\t\t\t\tthis.zoomToCursor = false;\n\n\t\t\t\t}\n\n\t\t\t\t// handle the placement of the target\n\t\t\t\tif ( newRadius !== null ) {\n\n\t\t\t\t\tif ( this.screenSpacePanning ) {\n\n\t\t\t\t\t\t// position the orbit target in front of the new camera position\n\t\t\t\t\t\tthis.target.set( 0, 0, -1 )\n\t\t\t\t\t\t\t.transformDirection( this.object.matrix )\n\t\t\t\t\t\t\t.multiplyScalar( newRadius )\n\t\t\t\t\t\t\t.add( this.object.position );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// get the ray and translation plane to compute target\n\t\t\t\t\t\t_ray.origin.copy( this.object.position );\n\t\t\t\t\t\t_ray.direction.set( 0, 0, -1 ).transformDirection( this.object.matrix );\n\n\t\t\t\t\t\t// if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid\n\t\t\t\t\t\t// extremely large values\n\t\t\t\t\t\tif ( Math.abs( this.object.up.dot( _ray.direction ) ) < _TILT_LIMIT ) {\n\n\t\t\t\t\t\t\tthis.object.lookAt( this.target );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t_plane.setFromNormalAndCoplanarPoint( this.object.up, this.target );\n\t\t\t\t\t\t\t_ray.intersectPlane( _plane, this.target );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( this.object.isOrthographicCamera ) {\n\n\t\t\t\tconst prevZoom = this.object.zoom;\n\t\t\t\tthis.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom / this._scale ) );\n\n\t\t\t\tif ( prevZoom !== this.object.zoom ) {\n\n\t\t\t\t\tthis.object.updateProjectionMatrix();\n\t\t\t\t\tzoomChanged = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._scale = 1;\n\t\t\tthis._performCursorZoom = false;\n\n\t\t\t// update condition is:\n\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n\t\t\tif ( zoomChanged ||\n\t\t\t\tthis._lastPosition.distanceToSquared( this.object.position ) > _EPS ||\n\t\t\t\t8 * ( 1 - this._lastQuaternion.dot( this.object.quaternion ) ) > _EPS ||\n\t\t\t\tthis._lastTargetPosition.distanceToSquared( this.target ) > _EPS ) {\n\n\t\t\t\tthis.dispatchEvent( _changeEvent );\n\n\t\t\t\tthis._lastPosition.copy( this.object.position );\n\t\t\t\tthis._lastQuaternion.copy( this.object.quaternion );\n\t\t\t\tthis._lastTargetPosition.copy( this.target );\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t_getAutoRotationAngle( deltaTime ) {\n\n\t\t\tif ( deltaTime !== null ) {\n\n\t\t\t\treturn ( _twoPI / 60 * this.autoRotateSpeed ) * deltaTime;\n\n\t\t\t} else {\n\n\t\t\t\treturn _twoPI / 60 / 60 * this.autoRotateSpeed;\n\n\t\t\t}\n\n\t\t}\n\n\t\t_getZoomScale( delta ) {\n\n\t\t\tconst normalizedDelta = Math.abs( delta * 0.01 );\n\t\t\treturn Math.pow( 0.95, this.zoomSpeed * normalizedDelta );\n\n\t\t}\n\n\t\t_rotateLeft( angle ) {\n\n\t\t\tthis._sphericalDelta.theta -= angle;\n\n\t\t}\n\n\t\t_rotateUp( angle ) {\n\n\t\t\tthis._sphericalDelta.phi -= angle;\n\n\t\t}\n\n\t\t_panLeft( distance, objectMatrix ) {\n\n\t\t\t_v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\n\t\t\t_v.multiplyScalar( - distance );\n\n\t\t\tthis._panOffset.add( _v );\n\n\t\t}\n\n\t\t_panUp( distance, objectMatrix ) {\n\n\t\t\tif ( this.screenSpacePanning === true ) {\n\n\t\t\t\t_v.setFromMatrixColumn( objectMatrix, 1 );\n\n\t\t\t} else {\n\n\t\t\t\t_v.setFromMatrixColumn( objectMatrix, 0 );\n\t\t\t\t_v.crossVectors( this.object.up, _v );\n\n\t\t\t}\n\n\t\t\t_v.multiplyScalar( distance );\n\n\t\t\tthis._panOffset.add( _v );\n\n\t\t}\n\n\t\t// deltaX and deltaY are in pixels; right and down are positive\n\t\t_pan( deltaX, deltaY ) {\n\n\t\t\tconst element = this.domElement;\n\n\t\t\tif ( this.object.isPerspectiveCamera ) {\n\n\t\t\t\t// perspective\n\t\t\t\tconst position = this.object.position;\n\t\t\t\t_v.copy( position ).sub( this.target );\n\t\t\t\tlet targetDistance = _v.length();\n\n\t\t\t\t// half of the fov is center to top of screen\n\t\t\t\ttargetDistance *= Math.tan( ( this.object.fov / 2 ) * Math.PI / 180.0 );\n\n\t\t\t\t// we use only clientHeight here so aspect ratio does not distort speed\n\t\t\t\tthis._panLeft( 2 * deltaX * targetDistance / element.clientHeight, this.object.matrix );\n\t\t\t\tthis._panUp( 2 * deltaY * targetDistance / element.clientHeight, this.object.matrix );\n\n\t\t\t} else if ( this.object.isOrthographicCamera ) {\n\n\t\t\t\t// orthographic\n\t\t\t\tthis._panLeft( deltaX * ( this.object.right - this.object.left ) / this.object.zoom / element.clientWidth, this.object.matrix );\n\t\t\t\tthis._panUp( deltaY * ( this.object.top - this.object.bottom ) / this.object.zoom / element.clientHeight, this.object.matrix );\n\n\t\t\t} else {\n\n\t\t\t\t// camera neither orthographic nor perspective\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\t\t\t\tthis.enablePan = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t_dollyOut( dollyScale ) {\n\n\t\t\tif ( this.object.isPerspectiveCamera || this.object.isOrthographicCamera ) {\n\n\t\t\t\tthis._scale /= dollyScale;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\tthis.enableZoom = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t_dollyIn( dollyScale ) {\n\n\t\t\tif ( this.object.isPerspectiveCamera || this.object.isOrthographicCamera ) {\n\n\t\t\t\tthis._scale *= dollyScale;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\tthis.enableZoom = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t_updateZoomParameters( x, y ) {\n\n\t\t\tif ( ! this.zoomToCursor ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis._performCursorZoom = true;\n\n\t\t\tconst rect = this.domElement.getBoundingClientRect();\n\t\t\tconst dx = x - rect.left;\n\t\t\tconst dy = y - rect.top;\n\t\t\tconst w = rect.width;\n\t\t\tconst h = rect.height;\n\n\t\t\tthis._mouse.x = ( dx / w ) * 2 - 1;\n\t\t\tthis._mouse.y = - ( dy / h ) * 2 + 1;\n\n\t\t\tthis._dollyDirection.set( this._mouse.x, this._mouse.y, 1 ).unproject( this.object ).sub( this.object.position ).normalize();\n\n\t\t}\n\n\t\t_clampDistance( dist ) {\n\n\t\t\treturn Math.max( this.minDistance, Math.min( this.maxDistance, dist ) );\n\n\t\t}\n\n\t\t//\n\t\t// event callbacks - update the object state\n\t\t//\n\n\t\t_handleMouseDownRotate( event ) {\n\n\t\t\tthis._rotateStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\t_handleMouseDownDolly( event ) {\n\n\t\t\tthis._updateZoomParameters( event.clientX, event.clientX );\n\t\t\tthis._dollyStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\t_handleMouseDownPan( event ) {\n\n\t\t\tthis._panStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\t_handleMouseMoveRotate( event ) {\n\n\t\t\tthis._rotateEnd.set( event.clientX, event.clientY );\n\n\t\t\tthis._rotateDelta.subVectors( this._rotateEnd, this._rotateStart ).multiplyScalar( this.rotateSpeed );\n\n\t\t\tconst element = this.domElement;\n\n\t\t\tthis._rotateLeft( _twoPI * this._rotateDelta.x / element.clientHeight ); // yes, height\n\n\t\t\tthis._rotateUp( _twoPI * this._rotateDelta.y / element.clientHeight );\n\n\t\t\tthis._rotateStart.copy( this._rotateEnd );\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\t_handleMouseMoveDolly( event ) {\n\n\t\t\tthis._dollyEnd.set( event.clientX, event.clientY );\n\n\t\t\tthis._dollyDelta.subVectors( this._dollyEnd, this._dollyStart );\n\n\t\t\tif ( this._dollyDelta.y > 0 ) {\n\n\t\t\t\tthis._dollyOut( this._getZoomScale( this._dollyDelta.y ) );\n\n\t\t\t} else if ( this._dollyDelta.y < 0 ) {\n\n\t\t\t\tthis._dollyIn( this._getZoomScale( this._dollyDelta.y ) );\n\n\t\t\t}\n\n\t\t\tthis._dollyStart.copy( this._dollyEnd );\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\t_handleMouseMovePan( event ) {\n\n\t\t\tthis._panEnd.set( event.clientX, event.clientY );\n\n\t\t\tthis._panDelta.subVectors( this._panEnd, this._panStart ).multiplyScalar( this.panSpeed );\n\n\t\t\tthis._pan( this._panDelta.x, this._panDelta.y );\n\n\t\t\tthis._panStart.copy( this._panEnd );\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\t_handleMouseWheel( event ) {\n\n\t\t\tthis._updateZoomParameters( event.clientX, event.clientY );\n\n\t\t\tif ( event.deltaY < 0 ) {\n\n\t\t\t\tthis._dollyIn( this._getZoomScale( event.deltaY ) );\n\n\t\t\t} else if ( event.deltaY > 0 ) {\n\n\t\t\t\tthis._dollyOut( this._getZoomScale( event.deltaY ) );\n\n\t\t\t}\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\t_handleKeyDown( event ) {\n\n\t\t\tlet needsUpdate = false;\n\n\t\t\tswitch ( event.code ) {\n\n\t\t\t\tcase this.keys.UP:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\tif ( this.enableRotate ) {\n\n\t\t\t\t\t\t\tthis._rotateUp( _twoPI * this.keyRotateSpeed / this.domElement.clientHeight );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( this.enablePan ) {\n\n\t\t\t\t\t\t\tthis._pan( 0, this.keyPanSpeed );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase this.keys.BOTTOM:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\tif ( this.enableRotate ) {\n\n\t\t\t\t\t\t\tthis._rotateUp( - _twoPI * this.keyRotateSpeed / this.domElement.clientHeight );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( this.enablePan ) {\n\n\t\t\t\t\t\t\tthis._pan( 0, - this.keyPanSpeed );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase this.keys.LEFT:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\tif ( this.enableRotate ) {\n\n\t\t\t\t\t\t\tthis._rotateLeft( _twoPI * this.keyRotateSpeed / this.domElement.clientHeight );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( this.enablePan ) {\n\n\t\t\t\t\t\t\tthis._pan( this.keyPanSpeed, 0 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase this.keys.RIGHT:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\tif ( this.enableRotate ) {\n\n\t\t\t\t\t\t\tthis._rotateLeft( - _twoPI * this.keyRotateSpeed / this.domElement.clientHeight );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( this.enablePan ) {\n\n\t\t\t\t\t\t\tthis._pan( - this.keyPanSpeed, 0 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( needsUpdate ) {\n\n\t\t\t\t// prevent the browser from scrolling on cursor keys\n\t\t\t\tevent.preventDefault();\n\n\t\t\t\tthis.update();\n\n\t\t\t}\n\n\n\t\t}\n\n\t\t_handleTouchStartRotate( event ) {\n\n\t\t\tif ( this._pointers.length === 1 ) {\n\n\t\t\t\tthis._rotateStart.set( event.pageX, event.pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst position = this._getSecondPointerPosition( event );\n\n\t\t\t\tconst x = 0.5 * ( event.pageX + position.x );\n\t\t\t\tconst y = 0.5 * ( event.pageY + position.y );\n\n\t\t\t\tthis._rotateStart.set( x, y );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_handleTouchStartPan( event ) {\n\n\t\t\tif ( this._pointers.length === 1 ) {\n\n\t\t\t\tthis._panStart.set( event.pageX, event.pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst position = this._getSecondPointerPosition( event );\n\n\t\t\t\tconst x = 0.5 * ( event.pageX + position.x );\n\t\t\t\tconst y = 0.5 * ( event.pageY + position.y );\n\n\t\t\t\tthis._panStart.set( x, y );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_handleTouchStartDolly( event ) {\n\n\t\t\tconst position = this._getSecondPointerPosition( event );\n\n\t\t\tconst dx = event.pageX - position.x;\n\t\t\tconst dy = event.pageY - position.y;\n\n\t\t\tconst distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tthis._dollyStart.set( 0, distance );\n\n\t\t}\n\n\t\t_handleTouchStartDollyPan( event ) {\n\n\t\t\tif ( this.enableZoom ) this._handleTouchStartDolly( event );\n\n\t\t\tif ( this.enablePan ) this._handleTouchStartPan( event );\n\n\t\t}\n\n\t\t_handleTouchStartDollyRotate( event ) {\n\n\t\t\tif ( this.enableZoom ) this._handleTouchStartDolly( event );\n\n\t\t\tif ( this.enableRotate ) this._handleTouchStartRotate( event );\n\n\t\t}\n\n\t\t_handleTouchMoveRotate( event ) {\n\n\t\t\tif ( this._pointers.length == 1 ) {\n\n\t\t\t\tthis._rotateEnd.set( event.pageX, event.pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst position = this._getSecondPointerPosition( event );\n\n\t\t\t\tconst x = 0.5 * ( event.pageX + position.x );\n\t\t\t\tconst y = 0.5 * ( event.pageY + position.y );\n\n\t\t\t\tthis._rotateEnd.set( x, y );\n\n\t\t\t}\n\n\t\t\tthis._rotateDelta.subVectors( this._rotateEnd, this._rotateStart ).multiplyScalar( this.rotateSpeed );\n\n\t\t\tconst element = this.domElement;\n\n\t\t\tthis._rotateLeft( _twoPI * this._rotateDelta.x / element.clientHeight ); // yes, height\n\n\t\t\tthis._rotateUp( _twoPI * this._rotateDelta.y / element.clientHeight );\n\n\t\t\tthis._rotateStart.copy( this._rotateEnd );\n\n\t\t}\n\n\t\t_handleTouchMovePan( event ) {\n\n\t\t\tif ( this._pointers.length === 1 ) {\n\n\t\t\t\tthis._panEnd.set( event.pageX, event.pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst position = this._getSecondPointerPosition( event );\n\n\t\t\t\tconst x = 0.5 * ( event.pageX + position.x );\n\t\t\t\tconst y = 0.5 * ( event.pageY + position.y );\n\n\t\t\t\tthis._panEnd.set( x, y );\n\n\t\t\t}\n\n\t\t\tthis._panDelta.subVectors( this._panEnd, this._panStart ).multiplyScalar( this.panSpeed );\n\n\t\t\tthis._pan( this._panDelta.x, this._panDelta.y );\n\n\t\t\tthis._panStart.copy( this._panEnd );\n\n\t\t}\n\n\t\t_handleTouchMoveDolly( event ) {\n\n\t\t\tconst position = this._getSecondPointerPosition( event );\n\n\t\t\tconst dx = event.pageX - position.x;\n\t\t\tconst dy = event.pageY - position.y;\n\n\t\t\tconst distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tthis._dollyEnd.set( 0, distance );\n\n\t\t\tthis._dollyDelta.set( 0, Math.pow( this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed ) );\n\n\t\t\tthis._dollyOut( this._dollyDelta.y );\n\n\t\t\tthis._dollyStart.copy( this._dollyEnd );\n\n\t\t\tconst centerX = ( event.pageX + position.x ) * 0.5;\n\t\t\tconst centerY = ( event.pageY + position.y ) * 0.5;\n\n\t\t\tthis._updateZoomParameters( centerX, centerY );\n\n\t\t}\n\n\t\t_handleTouchMoveDollyPan( event ) {\n\n\t\t\tif ( this.enableZoom ) this._handleTouchMoveDolly( event );\n\n\t\t\tif ( this.enablePan ) this._handleTouchMovePan( event );\n\n\t\t}\n\n\t\t_handleTouchMoveDollyRotate( event ) {\n\n\t\t\tif ( this.enableZoom ) this._handleTouchMoveDolly( event );\n\n\t\t\tif ( this.enableRotate ) this._handleTouchMoveRotate( event );\n\n\t\t}\n\n\t\t// pointers\n\n\t\t_addPointer( event ) {\n\n\t\t\tthis._pointers.push( event.pointerId );\n\n\t\t}\n\n\t\t_removePointer( event ) {\n\n\t\t\tdelete this._pointerPositions[ event.pointerId ];\n\n\t\t\tfor ( let i = 0; i < this._pointers.length; i ++ ) {\n\n\t\t\t\tif ( this._pointers[ i ] == event.pointerId ) {\n\n\t\t\t\t\tthis._pointers.splice( i, 1 );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t_isTrackingPointer( event ) {\n\n\t\t\tfor ( let i = 0; i < this._pointers.length; i ++ ) {\n\n\t\t\t\tif ( this._pointers[ i ] == event.pointerId ) return true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t_trackPointer( event ) {\n\n\t\t\tlet position = this._pointerPositions[ event.pointerId ];\n\n\t\t\tif ( position === undefined ) {\n\n\t\t\t\tposition = new Vector2();\n\t\t\t\tthis._pointerPositions[ event.pointerId ] = position;\n\n\t\t\t}\n\n\t\t\tposition.set( event.pageX, event.pageY );\n\n\t\t}\n\n\t\t_getSecondPointerPosition( event ) {\n\n\t\t\tconst pointerId = ( event.pointerId === this._pointers[ 0 ] ) ? this._pointers[ 1 ] : this._pointers[ 0 ];\n\n\t\t\treturn this._pointerPositions[ pointerId ];\n\n\t\t}\n\n\t\t//\n\n\t\t_customWheelEvent( event ) {\n\n\t\t\tconst mode = event.deltaMode;\n\n\t\t\t// minimal wheel event altered to meet delta-zoom demand\n\t\t\tconst newEvent = {\n\t\t\t\tclientX: event.clientX,\n\t\t\t\tclientY: event.clientY,\n\t\t\t\tdeltaY: event.deltaY,\n\t\t\t};\n\n\t\t\tswitch ( mode ) {\n\n\t\t\t\tcase 1: // LINE_MODE\n\t\t\t\t\tnewEvent.deltaY *= 16;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2: // PAGE_MODE\n\t\t\t\t\tnewEvent.deltaY *= 100;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// detect if event was triggered by pinching\n\t\t\tif ( event.ctrlKey && ! this._controlActive ) {\n\n\t\t\t\tnewEvent.deltaY *= 10;\n\n\t\t\t}\n\n\t\t\treturn newEvent;\n\n\t\t}\n\n\t}\n\n\tfunction onPointerDown( event ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\tif ( this._pointers.length === 0 ) {\n\n\t\t\tthis.domElement.setPointerCapture( event.pointerId );\n\n\t\t\tthis.domElement.addEventListener( 'pointermove', this._onPointerMove );\n\t\t\tthis.domElement.addEventListener( 'pointerup', this._onPointerUp );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this._isTrackingPointer( event ) ) return;\n\n\t\t//\n\n\t\tthis._addPointer( event );\n\n\t\tif ( event.pointerType === 'touch' ) {\n\n\t\t\tthis._onTouchStart( event );\n\n\t\t} else {\n\n\t\t\tthis._onMouseDown( event );\n\n\t\t}\n\n\t}\n\n\tfunction onPointerMove( event ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\tif ( event.pointerType === 'touch' ) {\n\n\t\t\tthis._onTouchMove( event );\n\n\t\t} else {\n\n\t\t\tthis._onMouseMove( event );\n\n\t\t}\n\n\t}\n\n\tfunction onPointerUp( event ) {\n\n\t\tthis._removePointer( event );\n\n\t\tswitch ( this._pointers.length ) {\n\n\t\t\tcase 0:\n\n\t\t\t\tthis.domElement.releasePointerCapture( event.pointerId );\n\n\t\t\t\tthis.domElement.removeEventListener( 'pointermove', this._onPointerMove );\n\t\t\t\tthis.domElement.removeEventListener( 'pointerup', this._onPointerUp );\n\n\t\t\t\tthis.dispatchEvent( _endEvent );\n\n\t\t\t\tthis.state = _STATE.NONE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\n\t\t\t\tconst pointerId = this._pointers[ 0 ];\n\t\t\t\tconst position = this._pointerPositions[ pointerId ];\n\n\t\t\t\t// minimal placeholder event - allows state correction on pointer-up\n\t\t\t\tthis._onTouchStart( { pointerId: pointerId, pageX: position.x, pageY: position.y } );\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tfunction onMouseDown( event ) {\n\n\t\tlet mouseAction;\n\n\t\tswitch ( event.button ) {\n\n\t\t\tcase 0:\n\n\t\t\t\tmouseAction = this.mouseButtons.LEFT;\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\n\t\t\t\tmouseAction = this.mouseButtons.MIDDLE;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\n\t\t\t\tmouseAction = this.mouseButtons.RIGHT;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tmouseAction = -1;\n\n\t\t}\n\n\t\tswitch ( mouseAction ) {\n\n\t\t\tcase MOUSE.DOLLY:\n\n\t\t\t\tif ( this.enableZoom === false ) return;\n\n\t\t\t\tthis._handleMouseDownDolly( event );\n\n\t\t\t\tthis.state = _STATE.DOLLY;\n\n\t\t\t\tbreak;\n\n\t\t\tcase MOUSE.ROTATE:\n\n\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\tif ( this.enablePan === false ) return;\n\n\t\t\t\t\tthis._handleMouseDownPan( event );\n\n\t\t\t\t\tthis.state = _STATE.PAN;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( this.enableRotate === false ) return;\n\n\t\t\t\t\tthis._handleMouseDownRotate( event );\n\n\t\t\t\t\tthis.state = _STATE.ROTATE;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase MOUSE.PAN:\n\n\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\tif ( this.enableRotate === false ) return;\n\n\t\t\t\t\tthis._handleMouseDownRotate( event );\n\n\t\t\t\t\tthis.state = _STATE.ROTATE;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( this.enablePan === false ) return;\n\n\t\t\t\t\tthis._handleMouseDownPan( event );\n\n\t\t\t\t\tthis.state = _STATE.PAN;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tthis.state = _STATE.NONE;\n\n\t\t}\n\n\t\tif ( this.state !== _STATE.NONE ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t}\n\n\t}\n\n\tfunction onMouseMove( event ) {\n\n\t\tswitch ( this.state ) {\n\n\t\t\tcase _STATE.ROTATE:\n\n\t\t\t\tif ( this.enableRotate === false ) return;\n\n\t\t\t\tthis._handleMouseMoveRotate( event );\n\n\t\t\t\tbreak;\n\n\t\t\tcase _STATE.DOLLY:\n\n\t\t\t\tif ( this.enableZoom === false ) return;\n\n\t\t\t\tthis._handleMouseMoveDolly( event );\n\n\t\t\t\tbreak;\n\n\t\t\tcase _STATE.PAN:\n\n\t\t\t\tif ( this.enablePan === false ) return;\n\n\t\t\t\tthis._handleMouseMovePan( event );\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tfunction onMouseWheel( event ) {\n\n\t\tif ( this.enabled === false || this.enableZoom === false || this.state !== _STATE.NONE ) return;\n\n\t\tevent.preventDefault();\n\n\t\tthis.dispatchEvent( _startEvent );\n\n\t\tthis._handleMouseWheel( this._customWheelEvent( event ) );\n\n\t\tthis.dispatchEvent( _endEvent );\n\n\t}\n\n\tfunction onKeyDown( event ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\tthis._handleKeyDown( event );\n\n\t}\n\n\tfunction onTouchStart( event ) {\n\n\t\tthis._trackPointer( event );\n\n\t\tswitch ( this._pointers.length ) {\n\n\t\t\tcase 1:\n\n\t\t\t\tswitch ( this.touches.ONE ) {\n\n\t\t\t\t\tcase TOUCH.ROTATE:\n\n\t\t\t\t\t\tif ( this.enableRotate === false ) return;\n\n\t\t\t\t\t\tthis._handleTouchStartRotate( event );\n\n\t\t\t\t\t\tthis.state = _STATE.TOUCH_ROTATE;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TOUCH.PAN:\n\n\t\t\t\t\t\tif ( this.enablePan === false ) return;\n\n\t\t\t\t\t\tthis._handleTouchStartPan( event );\n\n\t\t\t\t\t\tthis.state = _STATE.TOUCH_PAN;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tthis.state = _STATE.NONE;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\n\t\t\t\tswitch ( this.touches.TWO ) {\n\n\t\t\t\t\tcase TOUCH.DOLLY_PAN:\n\n\t\t\t\t\t\tif ( this.enableZoom === false && this.enablePan === false ) return;\n\n\t\t\t\t\t\tthis._handleTouchStartDollyPan( event );\n\n\t\t\t\t\t\tthis.state = _STATE.TOUCH_DOLLY_PAN;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TOUCH.DOLLY_ROTATE:\n\n\t\t\t\t\t\tif ( this.enableZoom === false && this.enableRotate === false ) return;\n\n\t\t\t\t\t\tthis._handleTouchStartDollyRotate( event );\n\n\t\t\t\t\t\tthis.state = _STATE.TOUCH_DOLLY_ROTATE;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tthis.state = _STATE.NONE;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tthis.state = _STATE.NONE;\n\n\t\t}\n\n\t\tif ( this.state !== _STATE.NONE ) {\n\n\t\t\tthis.dispatchEvent( _startEvent );\n\n\t\t}\n\n\t}\n\n\tfunction onTouchMove( event ) {\n\n\t\tthis._trackPointer( event );\n\n\t\tswitch ( this.state ) {\n\n\t\t\tcase _STATE.TOUCH_ROTATE:\n\n\t\t\t\tif ( this.enableRotate === false ) return;\n\n\t\t\t\tthis._handleTouchMoveRotate( event );\n\n\t\t\t\tthis.update();\n\n\t\t\t\tbreak;\n\n\t\t\tcase _STATE.TOUCH_PAN:\n\n\t\t\t\tif ( this.enablePan === false ) return;\n\n\t\t\t\tthis._handleTouchMovePan( event );\n\n\t\t\t\tthis.update();\n\n\t\t\t\tbreak;\n\n\t\t\tcase _STATE.TOUCH_DOLLY_PAN:\n\n\t\t\t\tif ( this.enableZoom === false && this.enablePan === false ) return;\n\n\t\t\t\tthis._handleTouchMoveDollyPan( event );\n\n\t\t\t\tthis.update();\n\n\t\t\t\tbreak;\n\n\t\t\tcase _STATE.TOUCH_DOLLY_ROTATE:\n\n\t\t\t\tif ( this.enableZoom === false && this.enableRotate === false ) return;\n\n\t\t\t\tthis._handleTouchMoveDollyRotate( event );\n\n\t\t\t\tthis.update();\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tthis.state = _STATE.NONE;\n\n\t\t}\n\n\t}\n\n\tfunction onContextMenu( event ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\n\t}\n\n\tfunction interceptControlDown( event ) {\n\n\t\tif ( event.key === 'Control' ) {\n\n\t\t\tthis._controlActive = true;\n\n\t\t\tconst document = this.domElement.getRootNode(); // offscreen canvas compatibility\n\n\t\t\tdocument.addEventListener( 'keyup', this._interceptControlUp, { passive: true, capture: true } );\n\n\t\t}\n\n\t}\n\n\tfunction interceptControlUp( event ) {\n\n\t\tif ( event.key === 'Control' ) {\n\n\t\t\tthis._controlActive = false;\n\n\t\t\tconst document = this.domElement.getRootNode(); // offscreen canvas compatibility\n\n\t\t\tdocument.removeEventListener( 'keyup', this._interceptControlUp, { passive: true, capture: true } );\n\n\t\t}\n\n\t}\n\n\tconst __esModule = true ;\n\n\texports.OrbitControls = OrbitControls;\n\texports.__esModule = __esModule;\n\n}));\n",
      "relatedPaths": [
        "/home/user/projects/z_sap_btp_decp/node_modules/three/build/three.core.js",
        "/home/user/projects/z_sap_btp_decp/node_modules/three/examples/jsm/controls/OrbitControls.js"
      ],
      "imports": [],
      "dynamicImports": [],
      "generated": false,
      "isWebComponent": false,
      "isEntryPoint": true
    }
  ]
}